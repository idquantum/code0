

计算机简介
Linux
	发行版
	软件包管理工具
linux哲学思想
基础服务

计算机是什么
      	电子计算机，也叫做电脑（computer），是一种用于高速计算的电子计算机器。通过计算机，可以实现计算、存储等功能电子计算机，
		也叫做电脑（computer）

      	通过计算机，可以实现计算、存储等功能

      	计算机可分为超级计算机、工业控制计算机、网络计算机、个人计算机、嵌入式计算机等五类       													对于我们日常的学习、生活而言，计算机已经是必不可少的组成部分 
		通常，对于我们而言，计算机指的就是PC（personal computer）个人计算机

	计算机的组成
      一般而言，计算机的组成应该分为两部分：       
		一部分指的是硬件部分。根据冯诺伊曼提出的计算机体系架构，一台计算机主要分为五个部分：控制器、运算器、存储器、输入设备、输出设备 
		二部分指的是计算机软件。包括汇编语言、系统软件及应用软件，他们不像硬件一样“有形”，但只有软件硬件互相配合，才是一台标准的计算机组成

		运算器-\CPU
		控制器-/
		存储器-内存
		输入设备-键盘
		输出设备-显示器

	总线bus

	各组成的功能
		硬件部分
			控制器（Control）：CPU的组成部分之一。相当于计算机的中枢神经，通过控制器，可以有效的控制和协调整个计算机的如下动作
				– 保障不同数率传输的数据可以得到缓冲
				– 甄别IO设备传送数据的正错
				– 实现数据与数据之间的交换
				– 接收和识别命令

          	运算器（Datapath）：CPU的组成部分之一。包含算数逻辑单元（ALU）、累加器、状态寄存器、通用寄存器组等，主要作用如下       
				算数逻辑单元（ALU）：进行二位元的算术运算，如加减乘（不包括整数除）、移位等
				累加器（accumulator）：储存计算产生的中间结果。保证ALU不用将计算结果写入内存
				状态寄存器：存放两类信息
					1）体现当前指令执行结果的状态信息
					2）控制信息
				通用寄存器组：可用于传送和暂存数据，也可以参与算术逻辑运算，保存运算结果，通用寄存器组包括以下几类：数据寄存器、变址寄存器、指针寄存器、段寄存器、指令指针寄存器

      		存储器（memory）：存储程序和数据，并能在计算机运行过程中高速、自动地完成从程序或数据的存取，
				也就是俗称的内存RAM(Random Access Memory)

      		输入设备（Input）：外部设备之一。作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据输入到计算机。
				常见的输入设备有：键盘、鼠标、磁带机、磁盘机、光盘机等

     		输出设备（Output）：外部设备之一。作用是把计算机的中间结果或最后结果、机内的各种数据及文字等信息输出来。
				常见的输出设备有：CRT、打印机、绘图仪等

		软件部分       
			汇编语言（assembly language）：一种用于cpu的低级语言。它使用助记符代替二进制语言，方便人类的阅读及操作。但一种汇编语言只能与相对应的计算机系统结构对应，无法在不同平台移植

			系统软件（system software）：用来运行或控制硬件所开发的计算机软件，如操作系统、编译器、数据库等等

      		常见的系统软件包含：
			操作系统（Operating system）：控制与管理硬件及软件资源，并提供用户操作接口，完成人机交互的软件，常见的有Unix、GNU/Linux、 MAC OS X、Microsoft Windows等

			编译器（compiler）：将使用汇编语言编写的代码，转换成计算机可识别的机器语言，常见的有GCC      

			解释器（interpreter）：将高级编程语言一行一行解释运行。它的好处是可以消除编译整个程序的负担，缺点则是运行速度比较缓慢，且使用解释器的代码在运行过程中，不可脱离解释器。常见的使用解释器的语言包括Perl、Python、Ruby等       

			连接器（linker）：将由汇编器或编译器产生的目标文件和外部程序库链接为一个可执行文件       

			加载器（loader）：负责将程序加载到内存中，并配置内存与相关参数，使之能够运行       

			应用软件（application software）：为了某种特定用途而被开发的软件。它可以是一个特定的程序，也可以是一个由众多独立程序组成的庞大的软件系统


Linux
	是一种自由和开放源代码的类Unix操作系统。该操作系统的内核由Linus Torvalds于1991年10月5日首次发布。
	根据其发布的内核（kernel）搭配上GNU上的应用程序，成为了当今世界上运用领域最广泛、使用人数最多的操作系统。通常情况下，
	Linux被打包成供个人计算机和服务器使用的Linux发行版。

	Linux发行版包含Linux内核和支撑内核的实用程序和库，通常还带有大量可以满足各类需求的应用程序。个人计算机使用的Linux发行版通常包含X Window和一个相应的桌面环境，如GNOME或KDE.

Linux发行版（Linux distribution）

是一种为一般用户预先集成好的Linux操作系统及各种应用软件。一般不需要用户重新编译，在直接安装之后，只需要作出小幅度的更改设置即可。Linux发行版通常包含了桌面环境、办公包、媒体播放器、数据库等应用软件。这些操作系统通常使用Linux、以及来自GNU计划的软件、和基于X Window的图形界面组成。

Linux发行版通常分为商业发行版和社区发行版。也有少部分既不属于发行版又不属于社区发行版，其中最有名的是Slackware.

发行版：
	Redhat centos  Fedora
	Debian Ubuntu  
	SUSE
	arch
	gentoo

	软件包管理工具：
	应用程序组成：
	二进制程序
	库文件
	配置文件
	帮助文件
	
	有时候我们发现，可能一个程序会有很多文件，非常不利于安装卸载管理，于是，又产生了程序包管理器。      

	
 	程序包管理器的作用：    
		1）程序的组成文件打包成一个或有限几个文件；
		2） 安装；     
		3） 卸载；       
		4） 查询；  
		   
	dpkg  apt-get  Debian系使用
	rpm   yum 	   Red Hat系使用，S.u.S.E也有使用


GUN GNU'S not unix
	gpl
	gplv2
	gplv3
	lgpl

	apache
	bsd

Linux (linus)
POSIX 
GNU: gnu not unix
GPL: general public license


linux哲学思想：
	1.一切皆文件(sockets,进程，命令管道不是文件)
		目录、字符设备、块设备、 套接字、进程、线程、管道等都被视为是一个“文件”
		把几乎所有资源统统抽象为文件形式，包括硬件设备，甚至通信接口等 比如说：
			物理终端：/dev/console       
			虚拟终端：/dev/tty#（#为1~6）    
			串行终端：/dev/ttyS#      
			伪终端：/dev/pts/#    

   		把所有资源抽象成文件，不仅便于理解，且有助于管理
	2.由众多小程序组成，一个程序只实现一个功能，组合小程序完成复杂任务

	3.尽量避免与用户交互
		易于以编程的方式实现自动化任务

	4.使用纯文本文件保存配置信息
		文本是最易于实现的底层接口表现形式。通过文本保存，就可以使用文本编辑器实现大多数程序的管理工作

	5.提供机制，而非策略
		机制，是实现某个功能需要的原语操作和结构      
		策略，是某功能的具体实现      
		提供机制，而非策略，指的就是要给用户充分的自主可调配性

------------------------------------------------------------------------------------------------------------------

基础服务
DNS 
DHCP
NFS
Samba
Vsftpd
Tftp


lamp lnmp

集群cluster
	LB负载均衡(LoadBalance)
	HA高可用(high available)
	HP高性能(High Performance)

运维工具：
	ansible

	puppet saltspack

监控工具：
	zabbix

分布式

虚拟化技术
	xen
	kvm

大数据及处理
	Hadoop
	spark
	elk
	docker

Redhat认证
	RHCSA
	RHCE
	RHCA

培训：
加速知识获取过程
监督，克服惰性，学习氛围，克服审美疲劳

自学：
自学能力
克制力

what why when where who how？

初级：面试
3年后：内部推荐


-------------------------------------------------------------------------------------------------------------------	

多用户，多任务，安全，开源，免费，开放

内核kernel  shell 应用程序

内核版本：x.y.z-n
    x主版本号
    y次版本号
    z末版本号（内核修订状态）修订版本号 ， 表示修改的次数
    n

头两个数字合在一齐可以描述内核系列。如稳定版的2.6.0，它是2.6版内核系列
inux内核下里的ELsmp与EL与smp

在linux下ELsmp指出了当前内核是为ELsmp特别调校的 EL : Enterprise Linux ； smp : 表示支持多处理器 ， 表示该内核版本支持多处理器


发行版:
  redhat centos fodera
  debian ubuntu
  suse

tty（）控制台终端
pts（）虚拟终端

tty：tty1-tty6

图形界面切换到字符界面：
Ctrl + Alt + F1-F6
字符界面切换到图形界面：
Alt + F1-F6

shift + alt +T 新建终端
alt + 数字键   切换终端
alt + F4       关闭终端


shell提示符：
root ：#
other：$

PS1='[\u@\h \W]\$ '


显示当前shell：
echo $SHELL
cat /etc/shells
chsh -l

echo $USER $UID $ID $EUID $PWD $HOME $SHELL $LANG $MAIL $PATH $HOSTNAME 

文件系统
文件系统结构：

目录结构 	用处 																	目录全名
/           根目录
├── bin     用户二进制文件，所有用户使用的基本命令，不能单独分区，os启动用到的程序 	Binaries (二进制文件)
├── boot    内核引导配置文件，引导文件存放目录，vmlinuz，initramfs，gurb都在此目录
├── dev     存放设备文件和特殊文件 													Devices (设备)
├── etc     系统配置文件 															Etcetera (附加，等等)
├── home    普通用户家目录 															Home 普通用户宿主目录所在目录
├── lib     动态共享库，基本共享库文件，以及内核模块文件(/lib/modules) 				Library 库文件
├── lib64   x64专用共享库文件存放位置
├── lost+found  文件系统恢复时的恢复文件 											lost+found 
├── media   可卸载存储介质挂载点
├── mnt     文件系统临时挂载点 														mounts
├── opt     附加的应用程序包
├── proc    系统内存的映射目录，提供内核与进程信息 									Processes
├── root    root 用户主目录
├── sbin    存放系统二进制文件，管理类基本命令，不能单独分区，os启动用到的程序 		Superuser Binaries (超级用户的二进制文件)
├── srv     存放服务相关数据
├── sys     sys 虚拟文件系统挂载点
├── tmp     存放临时文件 															Temporary (临时)
├── usr     存放用户应用程序 														Unix Shared Resources
└── var     存放邮件、系统日志等变化文件 											Variable (变量)


交互界面
	GUI
		Gnome
		Kde
		Xfce
	CLI
		Bash
		Ksh
		Csh

命令   
	命令格式
	command  options [arguments]
	命令 	 选项     参数

   COMMAND:        发起一个命令      
	命令请求kernel将某个二进制程序运行为一个进程。程序本身只是一个静态文件，只有通过这个请求，才会转化为有生命周期的动态进程。
	命令本身是一个可执行的二进制格式程序文件（Linux哲学思想：一切皆文件），一般都存放在这些目录下

        普通命令：/bin，/usr/bin，/usr/local/bin
        管理命令：/sbin，/usr/sbin，/usr/local/sbin

    命令往往会调用到许多库文件，这些库可能许多程序都会遇到，我们形象的称之为共享库。         												这些共享库也是二进制文件，但是由于其没有程序执行入口，所以不能独立执行。
	只能被其他有执行入口的程序调用时才能执行，一般这些库都存放在这些目录下

       32bits的库：/lib，/usr/lib，/usr/local/lib
       64bits的库：/lib64，/usr/lib64，/usr/local/lib64

    注意：并非所有的命令都有一个在某目录与之相对应的可执行程序文件

       命令的格式：        命令必须遵循特定格式规范：比如说win的exe，msi，对于linux而言则是ELF
       命令的分类：        由shell程序自带的命令：内置命令（builtin）        shell程序是一种独特的程序，它的作用是负责解析用户提供的命令。

       独立的可执行程序文件：文件名即命令名：外部命令

       查看命令类型：        type COMMAND       

	OPTIONS:        
		指定命令的运行特性        
		一般选项有两种表现形式：       
		短选项：-C        
			例如-l -d       
			注意：
				有些命令的选项没有-       
				如果同一命令使用多个短选项，多数可以合并，比如说 -l -d就可以写作-ld
				短选项一般使用“ ”（空格）来分割      

		长选项：--word       
			例如--help --human-readable        
			注意： 长选项不能合并
			长选项一般用“=”来表示        

	ARGUMENTS:
		命令的作用对象，以及命令对什么生效
		注意：有些命令可以同时带多个参数，多个参数之间以空白字符分割


	内部命令与外部命令
		type command

		内部命令：shell程序的一部分，其包含的往往是一些简单的linux系统命令。
		它们被shell程序识别并通过shell内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。
		内部命令是写在bashy源码里面的，其执行速度通常比外部命令快。

		外部命令：linux系统中能够完成特定功能的脚本文件或二进制文件，每个外部命令对应了系统中的一个文件。
		外部命令是在bash之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin……等等。可通过echo $PATH命令查看外部命令的存储路径。 


创建的文件及目录，则需要按照如下的法则
	文件名使用法则：
		严格区分字符大小写：file1 File1 FILE1 并不是一个文件
		目录也是文件，
		在同一路径下，两个文件不能同名
		支持使用除”/“以外的任意字符，不建议使用特殊字符
		最长不得超过255个字符
		.开头的文件为隐藏文件

/ 根目录  路径分隔符

绝对路径  从/根目录起始的路径
相对路径  当前位置起始的路径。.用户当前操作所在的位置，而 ..  表示上级目录，要把 . 和 .. 当做目录来看。
 

历史命令
history
		-c
		-d
		-w

	!n
	!!
	!string
	!$
	esc + .


快捷键
	
	Tab 补全命令和路径

	Ctrl + a 移到命令行首
	Ctrl + e 移到命令行尾 

	Ctrl + u 从光标处删除至命令行首
	Ctrl + k 从光标处删除至命令行尾

	Ctrl + f 按字符前移（右向）
	Ctrl + b 按字符后移（左向）

 	Ctrl + xx：在命令行首和光标之间移动

 	Alt + f ：按单词前移（右向） 
 	Alt + b ：按单词后移（左向） 

	Ctrl + c 终止命令
	Ctrl + z 挂起命令
	Ctrl + d 退出当前终端，如果你使用 SSH 连接，它将会关闭。 如果你直接使用一个终端，该应用将会立刻关闭。  exit

	Ctrl + s 锁定终端
	Ctrl + q 解锁

	Ctrl + l 清空终端  clear

	ctrl + u 从尾部到头部的裁剪
	ctrl + k 是跟 ctrl + u 相反，从头到尾裁剪
	Ctrl + w 剪切光标至行首内容，可以用来清除输入的命令
	Ctrl + y 粘贴

	Ctrl + r  查找历史命令

	esc+b //移动到当前单词的开头
    esc+f //移动到当前单词的结尾
    esc+. //注意那个".“ 意思是获取上一条命令的(以空格为分隔符)最后的部分

    !! //执行上一条命令
    !pw //这是一个例子，是执行以pw开头的命令，这里的pw可以换成任何已经执行过的字符
    !pw:p //这是一个例子，是仅打印以pw开头的命令，但不执行，最后的那个“p”是命令固定字符

    !num //执行历史命令列表的第num条命令，num代指任何数字(前提是历史命令里必须存在)
    !$ //代指上一条命令的最后一个参数，该命令常用于shell脚本中
!$ ：上一条命令的最后一个参数， 与 Alt - . 和 $_ 相同。

!* ：上一条命令的所有参数

!*:p ：打印上一条命令是所有参数，也即 !*的内容。

^abc ：删除上一条命令中的abc。

^foo^bar ：将上一条命令中的 foo 替换为 bar

^foo^bar^ ：将上一条命令中的 foo 替换为 bar

!-n ：执行前n条命令，执行上一条命令： !-1， 执行前5条命令的格式是： !-5



    ↑(Ctrl+p) 显示上一条命令

↓(Ctrl+n) 显示下一条命令
Ctrl – k: 先按住 Ctrl 键，然后再按 k 键；
!?string? 执行含有string字符串的最新命令


Alt – k: 先按住 Alt 键，然后再按 k 键；

M – k：先单击 Esc 键，然后再按 k 键。


Alt+d 剪切光标之后的词
Esc+w 删除光标所在处之前的字符至其单词尾（以空格、标点等为分隔符）
Ctrl+t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符
Alt+t 交换当前与以前单词的位置
Alt+u 把当前词转化为大写
Alt+l 把当前词转化为小写
Alt+c 把当前词汇变成首字符大写


bash I/O重定向及管道
	
	程序： 指令 + 数据
		读入数据  input
		输出数据  output

	标准输入   0
	标准输出   1
	标准错误   2


>  覆盖重定向
>> 追加重定向

set -C
set +C

2>    覆盖重定向错误输出
2>>   追加重定向错误输出

标准输出和错误输出自各自定向至不同位置
	command > /root/sd.txt 2>/root/errot
	ls > 1.txt 2> 2.txt

合并标准输出和错误输出为同一数据流进行重定向
	&>  覆盖重定向
	&>> 追加重定向

	ls &> 1.txt

	command > /path/1.txt  2>&1
	command >> /path/1.txt  2>>&1

输入重定向
	<

	cat < 1.txt

tr
	-d
	-s
	tr abc ABC < 1.txt

<<  此处生成文档
	cat << EOF

	cat >> 1.txt << EOF

| 管道  把前一个的命令的输出作为后一个命令的输入
	cat 1.txt |grep ss

	最后一个命令在当前shell的子shell中执行

Linux是一个宏内核（monolithic kernel）系统。设备驱动程序可以完全访问硬件。
Linux内的设备驱动程序可以方便地以模块化（modularize）的形式设置，并在系统运行期间可直接装载或卸载。

Linux内核组成部分：
	进程管理（process management）
	定时器（timer）
	中断管理（interrupt management）
	内存管理（memory management）
	模块管理（module management）
	虚拟文件系统接口（VFS layer）
	文件系统（file system）
	设备驱动程序（device driver）
	进程间通信（inter-process communication）
	网络管理（network management）
	系统启动（system init）
-------------------------------------------------------------------------------------------------------------

			uname  		显示系统相关信息 								unix name
			tty 		显示当前工作终端 								Teletype
			startx 		用来启动X Window 								start x-window
			arch
			runlevel
			hostname
			lsmod List modules
			insmod: install module,载入模块
			rmmod：Remove module
			modprobe
			modinfo
			modutil 


uname	/bin/uname (unix name)
	显示系统相关信息
	-a 	全部信息
	-s	系统名称
	-o	操作系统名称
	-r	系统的发行版号
	-v	操作系统版本
	-n	主机名称
	-i	硬件平台
	-p	处理器类型
	-m	电脑类型

	cat /proc/version 显示内核版本
	cat /etc/issue	发行版本信息(开机显示)
	cat /etc/centos-release	发行版本信息


tty	/usr/bin/tty (Teletype)	
	显示当前工作终端
	# /dev/pts/0

startx /usr/bin/startx (start x-window)
		用来启动X Window，实际上是启动X Window程序
 		startx：在服务器上启动x会话     
		startx -w：在服务器上强制启动x会话

arch /bin/arch	(Architecture)
	显示当前主机的硬件架构类型
	# x86_64

runlevel /sbin/runlevel	
	显示当前运行级别
	# N 3
系统运行级别:
	0	关机
	1 	单用户模式
	2 	无NFS的多用户模式
	3 	完全多用户模式
	4 	未定义
	5 	图形界面
	6 	重启

hostname /bin/hostname
	显示和设置系统的主机名称
	# server-1
	# hostname server-2
	-i	显示ip
	# vi /etc/sysconfig/network

lsmod	显示已经加载到内核中的模块的状态信息
	第1列：表示模块的名称。 
	第2列：表示模块的大小。 
	第3列：表示依赖模块的个数。 
	第4列：表示依赖模块的内容

lscpu	查看的是cpu的统计信息

	cat /proc/cpuinfo 	查看cpu的详细信息

	cat /proc/meminfo	查看内存的详细信息


lspci	显示当前主机的所有PCI总线信息，以及所有已连接的PCI设备信息

lslogins  显示已知的用户信息
	

lsof（list open files）是一个列出当前系统打开文件的工具
	
	lsof -i :22   查看22端口现在运行的情况

硬件时钟  clock

hwclock
	-w  硬件时钟同步到系统
	-s  系统时间同步到硬件

帮助命令
	man  Manual
	info
	--help or -h

环境变量
$USER $PWD $OLDPWD $UID $EUID $SHELL $LANG $PATH $LOGNAME $HOSTNAME $MAIL



----------------------------------------------------------------------------------------------------------------
目录管理命令
	ls 			列出目录下的所有文件和目录 					list
	dir 		列出目录下的所有文件和目录 					directory
	tree 		以树状图列出目录的内容 						tree
	cd 			切换工作目录 								Change Directory
	dirs 		显示当前目录栈中的所有记录 					directory status
	pushd 		将目录路径添加到/放入目录栈(历史)中 		push directory
	popd  		将目录弹出栈 								pop directory
	pwd    		显示当前所在目录 							print working directory
	basename 	去掉路径信息，返回纯粹的文件名 				base name
	dirname 	去除文件名中的非目录部分，仅显示与目录有关的内容 directory name
	touch 		创建空文件,或者改变文件的时间戳  			touch
	stat 		显示文件或文件系统的详细信息				status
	ln  		创建软链接或硬链接							link
	link 		调用link函数创建从文件1到文件2的硬链接 		
	mv 			移动/重命名文件/目录 						move
	cp 			复制文件/目录  								copy
	rm 			删除目录或文件 								Remove
	mkdir 		创建目录  									Make Directory 
	rmdir 		删除空目录 									Remove directory
	file 		显示文件的类型。
	type 		显示命令的路径名或别名,	type用于判断另外一个命令是否是内置命令。
	md5sum 		计算和校验文件的MD5值。

	which 		查找二进制命令，按环境变量PATH路径查找。
	whereis 	查找二进制命令，按环境变量PATH路径查找。
	find 		从磁盘遍历查找文件或目录。
	xargs 		将标准输入转换成命令行参数。
	locate 		从数据库 (/var/lib/mlocate/mlocate.db) 查找命令，使用updatedb更新库。

ls 	/bin/ls (list)
	列出目录下的所有文件和目录
	-a：会显示所有文件，包括两个相对路径的文件"."和".."以及以点开头的隐藏文件
	-A：会列出绝大多数文件，即忽略两个相对路径的文件"."和".."
	-c：列出ctime
	-d：(direcorty)查看目录本身属性信息，不查看目录里面的东西。不加-d会查看里面文件的信息
	-g: 只显示组
	-G: 不显示组
	-F：给不同目录或文件加标识；在每一个文件的末尾加上一个字符说明该文件的类型。"@"表示符号链接、"|"表示FIFOS、"/"表示目录、"="表示套接字
	-h：(human)人类可读的格式，将字节换成k,将K换成M，将M换成G
	-i：(inode)权限属性的前面加上一堆数字
	-l：(long)长格式显示，即显示属性等信息(包括mtime)。注意：显示的目录大小是节点所占大小。像win一样计算目录大小时包括文件大小要用du -sh
	-m：使用逗号分隔各文件，当然，只适用于未使用长格式(ls -l)的情况
	-p：对目录加上/标识符以作区分
	-r：反转排序
	-R：递归显示，若目录下有文件，则以下之文件亦皆依序列出
	-S：按文件大小排序，默认降序排序
	-s：在每个文件或目录前列出文件或目录的大小（人类可读）
	-t：按修改时间排序内容。不加任何改变顺序的选项时，ls默认按照字母顺序排序
	-u：列出atime
	--color：显示颜色
	-1：(数值一)，以换行符分隔文件，当然，和-m或-l(小写字母)是冲突的
	-I pattern：忽略被pattern匹配到的文件

    --si 。这个参数和-h参数类似，但是-si以1000为单位，而-h以1024为单位 
    -l查看文件显示时间是modify的时间，列出文件的 mtime （最后修改时间）
    -tc filename 列出文件的 ctime （最后更改时间）
    -lu filename 列出文件的 atime（最后存取时间）

ls -l
-rw-------. 1 			root root  1181 Dec 30 23:59 anaconda-ks.cfg
类型，权限   硬链接数 	属主 属组   大小 内容修改时间  文件名

文件类型
	普通文件 	f
	目录文件 	d
	字符设备文件 	c
	块设备文件	b
	套接字文件 	s
	管道文件 	p
	链接文件 	l


	通配符				含义
		*			文件代表文件名中所有字符
	ls te*			查找以te开头的文件
	ls *html		查找结尾为html的文件
		？			代表文件名中任意一个字符
	ls ?.c			只找第一个字符任意，后缀为.c的文件
	ls a.?			只找只有3个字符，前2字符为a.，最后一个字符任意的文件
		[]			[”和“]”将字符组括起来，表示可以匹配字符组中的任意一个。“-”用于表示字符范围。
	[abc]			匹配a、b、c中的任意一个
	[a-f]			匹配从a到f范围内的的任意一个字符
	ls [a-f]*		找到从a到f范围内的的任意一个字符开头的文件
	ls a-f			查找文件名为a-f的文件,当“-”处于方括号之外失去通配符的作用
		\			如果要使通配符作为普通字符使用，可以在其前面加上转义字符。“?”和“*”处于方括号内时不用使用转义字符就失去通配符的作用。
	ls \*a			查找文件名为*a的文件



dir  /usr/bin/dir
	列出目录下的所有文件和目录
	用法同ls

vdir /usr/bin/vdir
	列出目录下的所有文件和目录
	用法同ls

tree /usr/bin/tree
	以树状图列出目录的内容
	-L：用于指定递归显示的深度，指定的深度必须是大于0的整数。
	-P：用于显示统配符匹配模式的目录和文件，但是不管是否匹配，目录一定显示。
	-I：用于显示除被通配符匹配外的所有目录和文件。

【 显示选项：】
	-a：用于显示隐藏文件，默认不显示。
	-d：指定只显示目录。
	-f：指定显示全路径。
	-i：不缩进显示。和-f一起使用很有用。
	-p：用于显示权限位信息。
	-h：用于显示大小。
	-u：显示username或UID(当没有username时只能显示UID了)。
	-g：显示groupname或GID。
	-D：显示文件的最后一次Mtime。
	--inodes：显示inode号。
	--device：显示文件或目录所属的设备号。
	-C：显示颜色。

【 输出选项：】
	-o filename：指定将tree的结果输出到filename文件中。


cd 	(builtin)
	切换工作目录 
	~
	-
	.
	..
	cd
	cd /etc 
	cd ~user 

路径展开符号
	.  ：(一个点)表示当前目录
	.. ：(两个点)表示上一层目录
	-  ：(一个短横线)表示上一次使用的目录，例如从/tmp直接切换到/etc下，"-"就表示/tmp
	~  ：(波浪符号)表示用户的家目录，例如"~account"表示account用户的家目录
	/dir/和/dir：一般都表示dir目录和dir目录中的文件。但在有些地方会严格区分是否加尾
	              随斜线，此时对于加了尾随斜线的表示此目录中的文件，不加尾随斜线的表示
	              该目录本身和此目录中的文件


dirs (builtin)
	显示当前目录栈中的所有记录（不带参数的dirs命令显示当前目录栈中的记录）

（1）格式：dirs  [-clpv]  [+n]  [-n]
（2）选项
		-c    删除目录栈中的所有记录
		-l     以完整格式显示
		-p    一个目录一行的方式显示
		-v    每行一个目录来显示目录栈的内容，每个目录前加上的编号index
		+N    显示从左到右的第n个目录，数字从0开始
		-N   显示从右到左的第n个日录，数字从0开始
		
注意：dirs始终显示当然目录, 再是堆栈中的内容；即使目录堆栈为空, dirs命令仍然只显示当然目录
dirs -v 


可以看出，目录栈中只有一个目录(当然是在栈顶)，就是当前所在的目录。当切换目录之后，栈中的目录也随之改变。
通过-c选项可以将目录栈中除当前目录之外的其它目录清除，由于上面的例子中目录栈只包含当前目录，所以没有变化。


+n的含义是从栈顶往栈底方向进行计数，从0开始；-n的含义刚好相反，从栈底向栈顶方向计数，从0开始。
实际上，从默认的dirs命令(不带任何参数)的输出来解释最好理解了：+n是指从左往右数，-n是指从右往左数，都是从0开始


pushd (builtin)
将目录加入到栈中，加入记录到目录栈顶部，并切换到该目录；若pushd命令不加任何参数，则会将位于记录栈最上面的2个目录对换位置

目录栈就是一个保存目录的栈结构，该栈结构的顶端永远都存放着当前目录。
（1）格式：pushd  [目录 | -N | +N]   [-n]
（2）选项
		+N   将第N个目录移至栈顶（从左边数起，数字从0开始）
		-N    将第N个目录移至栈顶（从右边数起，数字从0开始）
		-n    将目录入栈时，不切换目录

每次pushd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容。
pushd后面如果直接跟目录使用，会切换到该目录并且将该目录置于目录栈的栈顶,目录栈的栈顶永远存放的是当前目录。
pushd不带任何参数执行的效果就是，将目录栈最顶层的两个目录进行交换。


pushd abc
	abc def
可以看到我本来的工作目录是abc，执行pushd abc后将 abc路径压入栈中，得到返回值。而且当前目录也跳转了。
此时，再输入pushd会将栈顶目录和下一目录对调。即：

pushd 
def    abc
可以看到此时栈顶目录又变为def


popd (builtin)
删除目录栈中的记录；如果popd命令不加任何参数，则会先删除目录栈最上面的记录，然后切换到删除过后的目录栈中的最上面的目录

（1）格式：popd  [-N | +N]   [-n]
（2）选项
		+N    将第N个目录删除（从左边数起，数字从0开始）删除pushd添加的目录，以当前目录为准，从左向右数，删除第n个
		-N    将第N个目录删除（从右边数起，数字从0开始）删除pushd添加的目录，以当前目录为准，从右向左数，删除第n个
		-n    将目录出栈时，不切换目录

popd，作用与pushd相反，将栈顶的目录弹出，此时除非再一次使用pushd压栈，否则pushd无法再找到已弹出的目录。
每次popd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容。
popd不带任何参数执行的效果，就是将目录栈中的栈顶元素出栈。
位于堆栈顶部的目录是当前目录，它不能被pop出去的


pwd  (builtin)
	显示当前所在目录
	-L
	-P

basename  /bin/basename
	用于去掉路径信息，返回纯粹的文件名，如果指定的文件的扩展名，则将扩展名也一并去掉。
	basename /usr/bin/sort
              Output "sort".

       basename include/stdio.h .h
              Output "stdio".


dirname   /usr/bin/dirname
	去除文件名中的非目录部分，仅显示与目录有关的内容
	dirname /usr/bin/sort
              Output "/usr/bin".

       dirname stdio.h
              Output ".".

mv   /bin/mv
	移动/重命名文件/目录
	-i
	-f
	-v
	 mv file_1.txt /home/pungki/office
	 mv file_2.txt file_3.txt file_4.txt /home/pungki/office
	 mv *.txt /home/pungki/office
	 mv file_1.txt file_2.txt
	 mv /home/pungki/Documents/file_1.txt /home/pungki/Documents/file_2.txt = mv /home/pungki/Documents/{file_1.txt,file_2.txt}	 
"mv命令只能对单个文件重命名"，rename除了给单个文件重命名，还可以批量文件重命名。

rename  /usr/bin/rename
	rename fromtofile
	这个命令有三个参数，分别是from ： 修改什么名字，to：改成什么名字，file 需要修改的文件是哪些。
	基本的通配符有以下几个：
	?可替代单个字符
	*可替代多个字符
	[charset]可替代charset集中的任意单个字符

	有一批文件，都是以log开头的，log001.txt,  log002.txt ....... 一直到log100.txt
	现在想要把这批文件的log全部替换为history
		rename  log history log*

	将所有jpeg的后缀名图片文件修改为jpg文件。
		rename .jpeg .jpg *.jpeg

	将所有abc开头，.txt后缀名文件修改为.log文件。
		rename .txt .log abc*.txt


ln 某一个文件在另外一个位置建立一个同步的链接
	有两种链接方式，一种是硬链接（hard link），另一种是符号链接（symbolic link），又称软链接。
	硬链接和原有文件是存储在同一物理地址的两个不同的名字，因此硬链接是相互的；
	符号链接的内容只是一个所链接文件的文件名，在使用ls –l时，符号链接的第一项的第一位为“l”。 
	
	-b 删除，覆盖以前建立的链接
	-d 允许超级用户制作目录的硬链接
	-f 强制执行
	-i 交互模式，文件存在则提示用户是否覆盖
	-n 把符号链接视为一般目录
	-s 软链接(符号链接)
	-v 显示详细的处理过程

	创建软链接 		ln  -s  [源文件或目录]  [目标文件或目录]
	删除软链接 		和删除普通的文件是一样的，删除都是使用rm来进行操作
	修改软链接 		ln –snf  [新的源文件或目录]  [目标文件或目录]   这将会修改原有的链接地址为新的地址

	1，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；
	2，ln的链接又软链接 和硬链接两种，
         软链接就是ln -s src  dst,它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，
         硬链接ln src  dst,没有参数-s, 它会在你选定的位置上生成一个和源文件大小相同的文件，
		 无论是软链接还是硬链接，文件          都保持同步变化。 
	3，指向一个文件的所有 硬链接都删掉的话文件的内容才会被删掉
          软链接只要删掉了源链接文件，软链接也就失效了

	4，目录不能做硬链接
	5，硬链接不能跨分区


link 调用 link 函数创建从既存的文件1 到文件2 的硬链接。
link 文件1 文件2
	link a1 a2 建立a1的硬链接a2


cp  复制文件/目录 
	-a  = pdr
	-r
	-i
	-d
	-f
	-l
	-p 
	-v 

rm  删除目录或文件
	-r
	-f
	-i

unlink 文件
调用 unlink 函数删除指定的文件,和rm命令作用一样
unlink只能删除文件，不能删除目录
	unlink abc  删除abc

mkdir  创建目录
	-p
	-v
rmdir  删除空目录
	-p
	-v


文件： metadata  data

	atime 访问时间       读取
	ctime 状态改变时间   metadata
	mtime 修改时间       data

	
touch 	创建空文件或者修改时间  		
		touch file 
	-a	只修改文件的access(访问)时间
		touch -a file1 
	-c	如果文件不存在,则不要进行创建
		touch -c file1 
	-d	使用指定的日期时间，而非现在的时间
			Sun, 29 Feb 2004 16:21:42 -0800 
			"2004-02-29 16:21:42"
			"next Thursday"
			10-December-2013
	-t 	使用指定的日期时间，而非现在的时间  CC]YY]MMDDhhmm[.SS]
			touch -t 201001010212.23 file 
	-m	指修改Modify(修改)时间,而不修改access(访问)时间
		touch -m file2 
	-r 	把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同   后者时间和前者一样
			touch file1 file2 

	
Linux文件与目录的三种时间状态

1.      mtime(medify time):最后一次修改文件或目录的时间
2.      ctime(chang time) :最后一次改变文件或目录(改变的是原数据即:属性)的时间
	如:记录该文件的inode节点被修改的时间。touch命令除了-d和-t选项外都会改变该时间。而且chmod,chown等命令也能改变该值。
3.      atime(access time)::最后一次访问文件或目录的时间

对于文件:
    当修改mtime时,ctime必须随着改变.因为文件大小等都属性；
有人说说atime也一定会改变，要想修改文件必须先访问；其实是不对的
不必访问文件就能修改其内容：如：#echo “This is a test !” >> /etc/issue,
issue文件内容会变，但并没有访问文件，所以atime并没有改变.
 
对于目录：
     访问一个目录其atime改变，mtime ，ctime不变；修改一个目录：
在一个目录下touch一个文件，
mtime与ctime会改变，atime不一定会变；
atime改变，mtime ，ctime不变情况：



文件的 Access time 也就是 ‘atime’ 是在读取文件或者执行文件时更改的。
文件的 Modified time 也就是 ‘mtime’ 是在写入文件时随文件内容的更改而更改的。
文件的 Change time 也就是 ‘ctime’是在写入文件、更改所有者、权限或链接设置时随inode 的内容更改而更改的。 
因此，更改文件的内容即会更改mtime 和ctime，但是文件的ctime 可能会在 mtime 未发生任何变化时更改，
例如，更改了文件的权限，但是文件内容没有变化。 如何获得一个文件的atime mtime 以及ctime .


(1).atime只在文件被打开访问时才改变，若不是打开文件编辑内容(如重定向内容到文件中)，则ctime和mtime的改变不会引起atime的改变;

(2).mtime的改变一定引起ctime的改变，而访问文件时(例如cat)，atime不一定会改变，所以atime"改变"(这个改变是假象，见下文分析)不一定会影响ctime。(见下面的relatime说明)

file不存在：touch file创建文件
file存在：	touch file 修改文件atime，ctime和mtime。
	touch -a file 只修改atime
	touch -m file 修改mtime，ctime跟着改变。

	touch -t 201001010102.23 file 修改atime，mtime。ctime不变
	[[CC]YY]MMDDhhmm [.SS]
		CC - 年份的前两位 
		YY - 年份的后两位 
		MM - 月份 [01-12]
		DD - 日期 [01-31]
		hh - 时 [00-23]
		mm - 分 [00-59]
		SS - 秒 [00-61]
	touch -d '1 year ago 13:43:07' file_3.txt
	touch -d '10-December-2013' file_3.txt
	touch -d "10/13/2013" *.sh
	touch -d "6:03pm" file 
	touch -d "05/06/2000" file 
	touch -d "6:03pm 05/06/2000" file
	touch -r file1 file 设置后者时间戳和前者一样 ，atime，mtime


stat  显示文件或文件系统的详细信息

-f　　不显示文件本身的信息，显示文件所在文件系统的信息
-L　　显示符号链接
-t　　简洁模式，只显示摘要信息

事实上，stat命令显示的是文件的I节点信息。Linux文件系统以块为单位存储信息，为了找到某一个文件所在存储空间的位置，用I节点对每个文件进行索引。
所谓的I节点，是文件系统管理的一个数据结构，是一个64字节长的表，包含了描述文件所必要的全部信息，其中包含了文件的大小，类型，存取权限，文件的所有者

which	在PATH变量指定的路径中搜索某个系统命令的位置
	# which cmd 
 
whereis 通过预先生成的一个文件列表库去查找跟给出的文
件名相关的文件。
语法： whereis [-bmsu] [文件名称]
‘-b’ : 只找binary 文件
‘-m’ : 只找在说明文件manual 路径下的文件
‘-s’ : 只找source 来源文件
‘-u’ : 没有说明档的文件

locate
	yum install mlocate
	updatedb
	locate passwd
		-i
		-c
		-b
	
locate
	find


	locate:
	 yum install mlocate
	 updatedb
	 locate vim


find
在给定的目录下查找符合给定条件的文件
　　find [OPTIONS] [查找起始路径] [查找条件] [处理动作]

	一、OPTIONS参数
　　　　-P、-L、-H：控制软连接的对待方式，用的不多。不介绍了
 
　　	二、查找路径
　　　　就是个目录路径，相对和绝对都可以。
 
　　	三、查找条件

	 	find /path -option pattern 
	 		支持通配
	 			* ? [] [^]
inum：根据文件的inode编号查找。

-links n：根据文件连接数查找。

-samefile name：找到跟name指定的文件完全一样的文件，就是说两个文件是硬连接关系。

	 		-name 根据名称查找
	 		-iname 不区分名称字母大小写
	 		-regex "PATTERN"  正则，以"PATTERN"匹配整个文件路径字符串，而不是文件名
	 			基于正则表达式的模式查找，匹配的是整个路径，而非单个文件名。
	 	1 . c：字节单位。 
2 . b：块为单位，块大小为512字节，这个是默认单位。 
3 . w：以words为单位，words表示两个字节。 
4 . k：以1024字节为单位。 
5 . M：以1048576字节为单位。 
6 . G：以1073741824字节温单位。



	 		-size 根据文件的大小查找，常用单位：k, M, G
	 			-size [+|-]n  bmg
	 				 n  [n,n+1）
	 				+n 	[n+1,∞）
	 				-n  [0,n)
	 		-empty

			-size [+|-]#UNIT
　　　　　　　　　　常用单位：k, M, G
　　　　　　　　　　　　#UNIT：(#-1, #]
　　　　　　　　　　　　-#UNIT：[0,#-1]
　　　　　　　　　　　　+#UNIT：(#, oo)

				1、1k时:a3只有15个字节，也被算做1k也查询，即条件符合大于0k ( #-1 )，小于等于1k (#)
　　　　　　　　　　　　	2、+1k时:a和a1满足大于1k(#)的条件
　　　　　　　　　　　　	3、-62k时:只有a3满足大于等于0，小于等于 61k（#-1）的要求。


	 		-type 根据文件的类型查找
	 			find ./ -type d

		 			b 块设备 文件
		 			c 字符设备文件
		 			d  目录文件
		 			f  普通文件
		 			l  符号链接文件
		 			s 套接字文件
		 			p 管道文件 

	 		-user  查找属主指定用户的所有文件
	 		-group 查找属组指定组的所有文件
	 		-uid  查找属主指定的UID的所有文件
	 		-gid  查找属组指定的GID的所有文件
	 		-nouser  查找没有属主的文件   
	 		-nogroup 查找没有属组的文件
			用户删除后，原先属于此用户的文件的属主，属组会变为uid，gid，此时此文件为无主文件

	 		-atime  文件的最后访问时间
	 		+n/-n   访问或执行时间大于/小于n 天的文件
	 			     n  [n,n+1）
	 				+n 	[n+1,∞）   天为单位
	 				-n  [0,n)

	 				-atime [+|-]#
　　　　　　　　　　　　　　#：[#, #-1) ：最后访问时间在#天前（大于等于#天前，小于#-1天前）
　　　　　　　　　　　　　　　　　　　　等价于最后访问时间与当前的时间差 大于 (#-1)*24小时，小于等于 #*24小时
　　　　　　　　　　　　　　-#：(#, 0] ：最后访问时间在#天以内，不包括24小时前的那一刻。
　　　　　　　　　　　　　　　　　　　　等价于最后访问时间与当前的时间差小于 #*24小时
　　　　　　　　　　　　　　+#：(oo, #-1] ：最后访问时间在#-1天以前的。包括#-1天前
　　　　　　　　　　　　　　　　　　　　等价于最后访问时间与当前的时间差大于等于 #*24小时


	 		-ctime  文件最后改变时间
	 		+n/-n 	写入、更改inode 属性（例如更改所有者、权限或者链接）时间大于/小于n 天的文件
	 		-mtime  文件的最后修改时间
	 		+n/-n 	写入时间大于/小于n 天的文件
	 		-amin     分钟为单位
	 		-cmin
	 		-mmin
			-name

	 		-perm
	 			[+|-]mode
	 			mode    精确匹配  如 -perm 600  
	 			+mode   ugo权限中有1位匹配即可
	 			-mode   每一类用户都满足为其指定的权限 
根据权限查找
　　　　　　　　-perm
　　　　　　　　-perm [/|-]mode
　　　　　　　　　　mode：精确权限匹配；
　　　　　　　　　　/mode：任何一类用户(u,g,o)的权限中的任何一位(r,w,x)符合条件即满足；9位权限之间存在“或”关系；
　　　　　　　　　　-mode：每一类用户(u,g,o)的权限中的每一位(r,w,x)同时符合条件即满足。9位权限之间存在“与”关系；

（1）：精确查找。就是匹配权限值完全相等的；
（2）：/mode。 只要有一组用户匹配到一个权限即可。
　　　　　　　　　　通俗说：就是属主拥有给定属主权限的某一个，或者数组拥有给定权限的某一个，或者其他用户拥有给定权限的某一个即可。
（3）：-mode。并且的关系。
　　　　　　　　　　通俗说：就是给定的属主权限必须拥有。并且给定的数组权限必须拥有。并且给定的其他用户权限必须拥有。

查找用户有写权限或者组用户有写权限的文件或目录
find ./ -perm /220
find ./ -perm /u+w,g+w
find ./ -perm /u=w,g=w

查找所有者权限有读权限的目录或文件
find ./ -perm -u=r

查找用户组权限有读权限的目录或文件
find ./ -perm -g=r

查找其它用户权限有读权限的目录或文件
find ./ -perm -o=r


-print: 显示
-ls：类似ls -l的形式显示每一个文件的详细
-quit: 查找到一个就退出
-delete: 删除匹配到的行
-ok COMMAND {} \; 每一次操作都需要用户确认,{}表示引用找到的文件,是占位符
-exec COMMAND {} \; 每次操作无需确认


	 		处理动作
	 			-ls
	 			-delete
	 			-fls /path/to/file  长格式保存查找到的信息
	 			-ok command {} \;   需要用户交互确认
	 			-exec command {} \; 需要用户交互确认
	 			find查找的文件传递给后面命令，符合条件的文件一次性传递给后面的命令，有些命令不能接受过多参数，可能会失败
	 				find /home -nouser -exec {} {}.bak \;

	 			find | xargs command

	 		组合条件：
	 			与 -a
	 			或 -o
	 			非 -not  or  !

	 		find / \(-nouser -o -nogroup\) -ls
摩根定律：
	 		!A -a !B = !(A -o B)
	 		!A -o !B = !(A -a B)


find /PATH -A -a -B   	=  	find /PATH \( -A -a  -B \)
	find /usr/  -type f -a  -user root  |xargs ls -lh >>a1   
	find /usr/  \( -type f -a  -user root \)  |xargs ls -lh >>a2 

		find /PATH ! -A -a -B   	=  	find /PATH \( !-A -a  -B \)  =  find /PATH ! \( ! -A -a  -B \)
			find /usr/  ! -type f -a  -user root  |xargs ls -lh >>a1   
			find /usr/  \( ! -type f -a  -user root \)  |xargs ls -lh >>a2 

		find /PATH -A -a ! -B   	=  	find /PATH \( -A -a  !-B \)  =  	find /PATH ! \( -A -a  ! -B \)
			find /usr/  -type f -a  ! -user root  |xargs ls -lh >>a3
			find /usr/  \( -type f -a ! -user root \)  |xargs ls -lh >>a4   

find /PATH -A -o -B   	=  	find /PATH \( -A -o  -B \)
	find /usr/  -type f -o  -user root  |xargs ls -lh >>a3
	find /usr/  \( -type f -o  -user root \)  |xargs ls -lh >>a4

		find /PATH ! -A -o -B   	=  	find /PATH \( ! -A -o  -B \)
			find /usr/  ! -type f -o  -user root  |xargs ls -lh >>a1
			find /usr/  \( ! -type f -o  -user root \)  |xargs ls -lh >>a2

		find /PATH -A -o ! -B   	=  	find /PATH \( -A -o  ! -B \)
			find /usr/  -type f -o  ! -user root  |xargs ls -lh >>a3
			find /usr/  \( -type f -o ! -user root \)  |xargs ls -lh >>a5  

find /PATH ! -A -a ! -B   	=  	find /PATH ! \( -A -o  -B \)  =  find /PATH  \( !-A -a  !-B \)
	find /usr/ ! -type f -a ! -user root  |xargs ls -lh >>a5    
	find /usr/ ! \(  -type f -o  -user root \)  |xargs ls -lh >>a6

		find /PATH ! -A -a -B   	=  	find /PATH ! \(  -A -o  ! -B \)
			find /usr/ ! -type f -a -user root  |xargs ls -lh >>a1 
			find /usr/ ! \(  -type f -o ! -user root \)  |xargs ls -lh >>a2
		
		find /PATH -A -a ! -B   	=  	find /PATH ! \( -A -o  ! -B \)
			find /usr/ -type f -a ! -user root  |xargs ls -lh >>a5    
			find /usr/ ! \(  ! -type f -o  -user root \)  |xargs ls -lh >>a6


find /PATH ! -A -o ! -B   	=  	find /PATH ! \( -A -a  -B \) =  find /PATH  \( !-A -o  !-B \)
	find /usr/ ! -type f -o ! -user root  |xargs ls -lh >>a7
	find /usr/ ! \(  -type f -a  -user root \)  |xargs ls -lh >>a8

		find /PATH ! -A -o -B   	=  	find /PATH ! \( ! -A -a  -B \)
			find /usr/ ! -type f -o ! -user root  |xargs ls -lh >>a7
			find /usr/ ! \(  -type f -a  -user root \)  |xargs ls -lh >>a8

		find /PATH -A -o ! -B   	=  	find /PATH ! \( -A -a  ! -B \)
			find /usr/ -type f -o ! -user root  |xargs ls -lh >>a7
			find /usr/ ! \(  ! -type f -a  -user root \)  |xargs ls -lh >>a8







find -user joe -not -group joe

find -user joe -o -user jane  

find -not −userjoe−o−userjane−userjoe−o−userjane

find / -user joe -o -uid 500

 

find ./ -path './dir0*' -a -prune -o -name *.txt -print

命令行的意思是：如果目录dir0存在（即-a左边为真），则求-prune的值，-prune 返回真，‘与’逻辑表达式为真（即-path './dir0*' -a -prune 为真），find命令将在除这个目录以外的目录下查找txt后缀文件并打印出来；如果目录dir0不存在（即-a左边为假），则不求值-prune ，‘与’逻辑表达式为假，则在当前目录下查找所有txt后缀文件。

 

在我的机器上，我想查找在根下既所有者即不是root也不是Tom的文件
find / ! \( -user root -o -user Tom \) -ls


	-exec
	-perm
	-newer
	

处理动作：
　　　　　　　　　　-print：输出至标准输出；默认的动作；
　　　　　　　　　　-ls：类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息；
　　　　　　　　　　-delete：删除查找到的文件；
　　　　　　　　　　-fls /PATH/TO/SOMEFILE：把查找到的所有文件的长格式信息保存至指定文件中；
　　　　　　　　　　-ok COMMAND {} \; ：对查找到的每个文件执行由COMMAND表示的命令；每次操作都由用户进行确认；
　　　　　　　　　　-exec COMMAND {} \; ：对查找到的每个文件执行由COMMAND表示的命令；
 
　　　　　　　　　　注意：find传递查找到的文件路径至后面的命令时，是先查找出所有符合条件的文件路径，并一次性传递给后面的命令；
 
　　　　　　　　　　　　但是有些命令不能接受过长的参数，此时命令执行会失败；另一种方式可规避此问题：
　　　　　　　　　　　　　find | xargs COMMAND

find 


	
	-ok
	-exec
	对于find命令找到的文件执行该参数所给出的shell命令，比如：

              find -name  test.txt -exec rm -f test.tx {} \；找到test并删除此文

              件，该命令一定要注意{}和\之间和空格，不要遗漏最后的“；”

	-print
	标准输出，比如：find / ‘*.NCT’-print >a.txt，代表将根目录下所

               的以nct命名的文件list输入到a.txt中
	
	-print：默认的处理动作，显示至屏幕

-ls：类似于对查找到的文件执行“ls -l”命令

-delete：删除查找到的文件

-fls file：查找到的所有文件的长格式信息保存至指定文件中

-ok COMMAND {} \; 对查找到的每个文件执行由COMMAND指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认

-exec COMMAND {} \; 对查找到的每个文件执行由COMMAND指定的命令

{}: 用于引用查找到的文件名称自身

find传递查找到的文件至后面指定的命令时，查找到所有符合条件的文件一次性传递给后面的命令


find的操作符（OPERATORS）实际上是用来连接多个表达式和确定其逻辑关系用的。如：

[root@zorrozou-pc0 zorro]# find /etc -name "pass*" -type f
/etc/passs/passwd
/etc/default/passwd
/etc/pam.d/passwd
/etc/passwd-
/etc/passwd

这个find命令中使用了两个表达式，他们之间没有任何分隔，这是实际上表达的含义是，找到两个条件都符合的文件。实际上就是表达式的逻辑与关系，这跟-a参数连接或者-and参数一样：

[root@zorrozou-pc0 zorro]# find /etc -name "pass*" -a -type f
/etc/passs/passwd
/etc/default/passwd
/etc/pam.d/passwd
/etc/passwd-
/etc/passwd
[root@zorrozou-pc0 zorro]# find /etc -name "pass*" -and -type f
/etc/passs/passwd
/etc/default/passwd
/etc/pam.d/passwd
/etc/passwd-
/etc/passwd

除了逻辑与关系以外，还有逻辑或关系：

[root@zorrozou-pc0 zorro]# find /etc -name "pass*" -o -type f

[root@zorrozou-pc0 zorro]# find /etc -name "pass*" -or -type f

表示两个条件只要符合其中一个都可以。

在条件表达式前面加!表示对表达式取非。同样的也可以用-not参数。另外如果表达式很多，可以使用( expr )确定优先级，如：

[root@zorrozou-pc0 zorro]# find / \( -name "passwd" -a -type f \) -o \( -name "shadow" -a -type f \)
1
这里表示的是：-name “passwd” -a -type f和-name “shadow” -a -type f是或关系。

最后



	find . -name stud
	find /root/ -name stud 
	find /root/ -iname STUD
	find / -type d -name stud
	find /root/ -type f -name cnu
	find / -type f -name "*.so"
	find / -type f -perm 0777 -print
	find /data/ -type f ! -perm 0777 -print
	find /usr/ -perm 0644
	find /root/ -size +100M -exec rm -rf {} \;
	find / -perm /u=s
	find / -type f -name *.mp3 -size +10M -exec rm {} \;
	find / -perm /u=r
	find / -perm /a=x
	find /root/ -type d -perm 0755 -print -exec chmod 000 {} \; 
	find /root/ -type f -name "1.txt" -print -exec rm -rf {} \;
	find /root/ -type f -name "*.txt" -print -exec rm -rf {} \; 
	find /tmp/ -type f -empty
	find /tmp/ -type d -empty
	find /root/ -type f -name ".*"
	find / -user oracle -type f
	find /home/ -user oracle
	find /home/ -group developer
	find /root/ -user root -iname "*.txt"
	find / -mtime 50
	find / -atime 50  
	find / -mtime +50 -mtime -100
	find / -cmin -60
	find / -mmin -60
	find / -amin -60
	find / -size 100M
	find / -size +50 -size 100M
	查找文件
find ./ -type f

查找目录
find ./ -type d

查找名字为test的文件或目录
find ./ -name test

查找名字符合正则表达式的文件,注意前面的‘.*’(查找到的文件带有目录)
find ./ -regex .*so.*\.gz

查找目录并列出目录下的文件(为找到的每一个目录单独执行ls命令，没有选项-print时文件列表前一行不会显示目录名称)
find ./ -type d -print -exec ls {} \;

查找目录并列出目录下的文件(为找到的每一个目录单独执行ls命令,执行命令前需要确认)
find ./ -type d -ok ls {} \;

查找目录并列出目录下的文件(将找到的目录添加到ls命令后一次执行，参数过长时会分多次执行)
find ./ -type d -exec ls {} +

查找文件名匹配*.c的文件
find ./ -name \*.c

打印test文件名后，打印test文件的内容
find ./ -name test -print -exec cat {} \;

不打印test文件名，只打印test文件的内容
find ./ -name test -exec cat {} \;

查找文件更新日时在距现在时刻二天以内的文件
find ./ -mtime -2

查找文件更新日时在距现在时刻二天以上的文件
find ./ -mtime +2

查找文件更新日时在距现在时刻一天以上二天以内的文件
find ./ -mtime 2

查找文件更新日时在距现在时刻二分以内的文件
find ./ -mmin -2

查找文件更新日时在距现在时刻二分以上的文件
find ./ -mmin +2

查找文件更新日时在距现在时刻一分以上二分以内的文件
find ./ -mmin 2

查找文件更新时间比文件abc的内容更新时间新的文件
find ./ -newer abc

查找文件访问时间比文件abc的内容更新时间新的文件
find ./ -anewer abc

查找空文件或空目录
find ./ -empty

查找空文件并删除
find ./ -empty -type f -print -delete

查找权限为644的文件或目录(需完全符合)
find ./ -perm 664

查找用户/组权限为读写，其他用户权限为读(其他权限不限)的文件或目录
find ./ -perm -664

查找用户有写权限或者组用户有写权限的文件或目录
find ./ -perm /220
find ./ -perm /u+w,g+w
find ./ -perm /u=w,g=w

查找所有者权限有读权限的目录或文件
find ./ -perm -u=r

查找用户组权限有读权限的目录或文件
find ./ -perm -g=r

查找其它用户权限有读权限的目录或文件
find ./ -perm -o=r

查找所有者为lzj的文件或目录
find ./ -user lzj

查找组名为gname的文件或目录
find ./ -group gname

查找文件的用户ID不存在的文件
find ./ -nouser

查找文件的组ID不存在的文件
find ./ -nogroup

查找有执行权限但没有可读权限的文件
find ./ -executable \! -readable

查找文件size小于10个字节的文件或目录
find ./ -size -10c

查找文件size等于10个字节的文件或目录
find ./ -size 10c

查找文件size大于10个字节的文件或目录
find ./ -size +10c

查找文件size小于10k的文件或目录
find ./ -size -10k

查找文件size小于10M的文件或目录
find ./ -size -10M

查找文件size小于10G的文件或目录
find ./ -size -10G



ln 创建文件的一个新链接

--------------------------------------------------------------------------------------------------------------------

文本文件查看类命令
	cat 				concatenate 连锁
	tac
	nl
	head
	tail
	tailf
	more
	less

cat
	-n
	-A
	-b
	-s
tac
nl
	-ba  =  cat -n
	-bt  =  cat -b
head
	-n20
	-c100
tail
	-n4
	-f
	-n +5
	-c100
	
tailf
	tailf  = tail -f
	-n 4 file   or  tailf -4 file

more
		+3 从笫n行开始显示
		-3 定义屏幕大小为n行
		+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示  
	    -c 从顶部清屏，然后显示

		Enter    向下n行，需要定义。默认为1行

		Ctrl+F   向下滚动一屏

		空格键  向下滚动一屏

		Ctrl+B  返回上一屏

		=       输出当前行的行号

		：f     输出文件名和当前行的行号

		V      调用vi编辑器

		!命令   调用Shell，并执行命令 

		q       退出more
			+3
			-3

less
		-i  忽略搜索时的大小写

		-m  显示类似more命令的百分比

		-N  显示每行的行号
		-o <文件名> 将less 输出的内容在指定文件中保存起来

		-Q  不使用警告音

		-s  显示连续空行为一行

		-S  行过长时间将超出部分舍弃

		-x <数字> 将“tab”键显示为规定的数字空格

		/字符串：向下搜索“字符串”的功能

		?字符串：向上搜索“字符串”的功能

		n：重复前一个搜索（与 / 或 ? 有关）

		N：反向重复前一个搜索（与 / 或 ? 有关）

		b  向后翻一页

		d  向后翻半页

		h  显示帮助界面

		Q  退出less 命令

		u  向前滚动半页

		y  向前滚动一行

		空格键 滚动一行

		回车键 滚动一页

		[pagedown]： 向下翻动一页

		[pageup]：   向上翻动一页


tee 一路输入两路输出
    tee 2.txt

    cat 3.txt|tee 4.txt

-------------------------------------------------------------------------------------------------------------------	

正则表达式
	grep 文本过滤工具
		grep egrep fgrep
	sed  流编辑器
	awk  文本报告生成器

	grep
		-i
		-c
		-n
		-v
		-o
		-w
		-A
		-B
		-C
		-E
		-F
		--color=auto
	贪婪匹配

	次数匹配
	*
	.
	.*
	\?
	\+
	\{m\}
	\{m,n\}
		\{0,n\}
		\{n,\}

	位置锚定
	^    	行首锚定
	$		行尾锚定
	^pattern$  	用于模式匹配整行
		^$   	空行
		^[[:space:]]$
	\< 或 \b   	词首锚定
	\> 或 \b 	词尾锚定
	\<pattern\> 匹配整个单词

	分组
	\(\)
		后向引用


	egrep

	fgrep
		所见即所得，在不使用正则表达式时，fgrep最快


sed
	-n 
	-
	
	
	
	
	]
	
	}
	0
	)
	
	正则表达式

	*
	.
	^
	$
	[]
	\
	\<\>
	\{m\}
	\{m,\}
	\{m,n\}
	
	?
	+
	()
	|


awk

	

---------------------------------------------------------------------------------------------------------------------

用户和权限管理
				useradd 	添加用户 						user add
				userdel 	删除用户 						user delete
				usermod 	修改用户信息 					user mode
				groupadd 	创建组 							group add
				groupdel 	删除组 							group delete
				groupmod 	修改组信息 						group mode
				id 			显示用户id信息 		 			Identity document
				passwd 		修改密码						password
				gpasswd 	设定组密码并指定组管理员 		group password
				su 			切换用户身份 					switch user
				sudo 		以系统管理者的身份执行指令 		super user do/substitute user do
				groups 		显示用户所在组的组成员 			groups
				newgrp 		切换用户组身份 					new group
				finger 		显示用户信息 					finger
				chfn 		改变用户信息 					change finger
				chsh 		改变用户shell 					change shell
				chown 		改变文件或目录的所有者 			change owner
				chmod 		修改文件或者目录权限			change mode
				chgrp 		改变文件或目录的所属组 			change group
				umask 		用户文件创建掩码 				user file-creatiopn mode mask
				lsattr 		显示文件隐藏属性				list attribute
				chattr 		改变文件隐藏属性 				change attribute
				getfacl 	取得某个文件/目录的ACL权限 		get file acl
				setfacl 	设置某个文件/目录的ACL权限 		set file acl


	useradd 	/usr/sbin/useradd
		-c
		-d
		-u
		-g
		-G
		-m
		-M
		-U
		-r
		-s
		-p
	默认值设置：/etc/default/useradd 
		useradd -D 
					-s
/etc/login.defs 
	userdel
		-r

	usermod
		-c
		-d
		-g
		-G
		-l
		-p
		-s
		-L
		-U
		-m

	id
		-u
		-g
		-G
		-n

	
	su
		su   			非登录式切换，不读取用户配置文件及用户变量
		su - = su -l 	登录式切换，读取用户配置文件及用户变量
		su - user -c "command"
		su -
	


	groupadd
		  -g
		  -o
		  -r
	groupdel

	groupmod 
		  -g
		  -o
		  -n
	groupmod
		-n
		-g
	

passwd
	-l
	-u
	-d
	-f 
	-S
	--stdin
	echo -e "yourpasswd\nyourpasswd"|passwd polar
	echo "yourpasswd"|passwd --stidin user1

  gpasswd
		-a
		-d
		-r 
		-A
		-M
		gpasswd groupname

	
mkpasswd /usr/bin/mkpasswd
	yum install expect
	-l
	-s
	-d

su
	su user
	su - user
	su - user1 -c "touch /tmp/1.txt"
	
	
	
	

	
	
	newgrp

	chfn

	chsh
		-l

	finger

	
	chmod
		augo +-= rwx

		r  w  x
		4  2  1

		directory：
			r : 查看目录下内容
			w : 在目录下创建，删除，移动，重命名文件或目录de
			x : 进入该目录

		file：
			r : 查看文件内容
			w : 编辑文件内容，新增,修改,删除文件内容的权限
			x : 执行该文件

		chmod a=rwx file
		chmod u=r,go=rw file
		chmod +x file
		chmod 700 file
		chmod -R 500 file

	chown
		-R
		user:user
		user.user
		user
		:user

		chown matrix file.txt
		chown :matrix file.txt
		chown -R matrix:matrix file.txt

	chgrp
		chgrp matrix file.txt
		-R

	
	umask
	umask 022

	umask
		umask只对当前用户的当前shell有效，永久有效要写在配置文件中。

				目录      	文件
	默认     	777 		666
	umask 	 
	   root  	022        	022
			 	755 		644
	   
	   普通用户  002        	002
			 	775 		664

	默认权限 -  umask  =  当前权限
	对于文件，如果权限减后结果存在x权限，则将其权限+1
	 666 - 322 = 344，实际却为444
lsattr
	-a
	-R

chattr
	+-=
	ASaci
	


‘+-=’ : 分别为增加、减少、设定
‘A’ : 增加该属性后，文件或目录的atime 将不可被修改；
‘S’ : 增加该属性后，会将数据同步写入磁盘中；
‘a’ : 增加该属性后，只能追加不能删除，非root 用户不能设定该属性；
‘c’ : 自动压缩该文件，读取时会自动解压；
‘i’ : 增加后，使文件不能被删除、重命名、设定链接接、写入、新增数据



	资源管理
	authentication 认证
	authorization  授权
	accounting     审计
	3A机制

	token，identity (username/password)

	linux用户 		UID
	管理员：root  	0
	普通用户      	1-65535
		系统用户		1-499    	对守护进程获取资源进行权限分配
		登录用户		500+	    交互式登录

	linux用户组 			GID
	管理员组：root  	0
	普通组      		1-65535
		系统组		1-499    	
		普通组		500+   


	linux安全上下文
		运行中的程序  进程(process)
			以发起者的身份运行
				root: cat
				tom : cat

		进程所能够访问的所有资源的权限取决于进程发起者的身份。

		前提：进程有属主和属组，文件有属主和属组
		1，任何一个可执行文件能不能启动为进程，取决于发起者对程序是否有可执行权限。
		2，启动为进程后，其进程的属主为发起者，进程的属组为发起者所属的组。
		3，进程访问文件时的权限，取决于进程的发起者：
			a，进程的发起者，同文件的属主，则应用属主的权限
			b，进程的发起者，属于文件的属组，则应用属组的权限
			c，应用文件"其他"权限

		进程所能够访问的所有资源的权限取决于进程发起者的身份。

 	特殊权限

	 	SUID  针对二进制文件
	 		1，任何一个可执行文件能不能启动为进程，取决于发起者对程序是否有可执行权限。
			2，启动为进程后，其进程的属主为原程序文件属主。
			3，进程访问文件时的权限，取决于进程的发起者

			权限设定
				chmod u+|-s file
	 	
			ll /usr/bin/passwd 
			-rwsr-xr-x. 1 root root 30768 Nov 24  2015 /usr/bin/passwd

			passwd显示的是rws，并非传统的rwx。用数字表示为4755。那么这个4是如何计算来的呢？
			当有特殊权限时，第一位数字可以是0，1(--t)，2(-s-)，3(-st)，4(s--)，5(s-t)，6(ss-)，7(sst)。
			再回过头来看passwd，它是s--所以是4



	 	SGID  针对二进制文件和目录
	 		默认情况下，用户创建文件时，文件的属组为此用户的基本组。
	 		一旦设定SGID后，用户创建文件时，文件的属组为此文件上级目录的属组。
	 		权限设定
				chmod g +|-s file
	 	
			设置在文件上，作用和set uid类似，前提是这个文件是可执行的二进制文件，当设置set gid后，执行该文件的用户会临时以该文件所属组的身份执行。
			若目录被设置这个权限后, 任何用户在此目录下创建的文件或目录都具有和该目录所属的组相同的组。

	 	Sticky 针对目录
	 		对于一个多人可写的目录，如果设置了sticky，每个用户仅能删除自己的文件
	 			权限设定
				chmod o+|-t file

		stick_bit可以理解为防删除位。一个文件是否可以被某用户删除，主要取决于该文件所在目录是否对该用户具有写权限。
		如果没有写权限，则这个目录下的所有文件都不能被删除，同时也不能添加新的文件。
		如果希望用户能够添加文件但同时不能删除该目录下的其他用户的文件，则可以对父目录增加该权限。
		设置它后，就算用户对目录具有写权限，也不能删除其他用户的文件。比如/tmp/目录就设置过该权限。

			ll -d /tmp/
			drwxrwxrwt. 8 root root 12288 Aug  6 07:34 /tmp/



		SUID SGID Sticky
		 4     2	1

			chmod 1777 a.txt

		几个权限位映射：
			SUID:user，占据user的可执行权限位
				s：属主拥有x权限
				S：属主没有x权限
			SGID:group，占据group的可执行权限位
				s：group拥有x权限
				S：group属主没有x权限
			Sticky:other，占据other的可执行权限位
				t：other拥有x权限
				T：other没有x权限

ACL即Access Control List 主要的目的是提供传统的owner,group,others的read,write,execute权限之外的具体权限设置，ACL可以针对单一用户、单一文件或目录来进行r,w,x的权限控制，对于需要特殊权限的使用状况有一定帮助。如，某一个文件，不让单一的某个用户访问。


	linux组的类别
		用户的基本组(主组)
			组名同用户名，且仅包含一个用户，私有组
		用户的附加组(额外组)

	/etc/passwd  用户名 UID 主组 
	/etc/shadow  用户名 密码
	/etc/group   用户名 
	/etc/gshadow

	/etc/passwd
	UserName:Password:UID:GID:Comment:Home:Shell

	/etc/shadow 
	UserName:加密后的密码:最近一次更改的日期:密码最小使用期限:密码最大使用期限:密码警告时间段:密码禁用期:密码过期日期:保留字段

	/etc/group
	GroupName:Password:GID:以当前组为附加组的用户列表(用，分割)

		单向密码
		md5sum 
			md5sum file/directory
		sha1
		sha224
		sha256
		sha384
		sha512

	雪崩效应
	定长输出

	密码复杂性策略
		1，使用数字，大小写字母，特殊字符中的至少3种
		2，足够长
		3，使用随机密码
		4，定期更换，不要使用近期使用过的密码


		yum install expect
			mkpasswd
				-l  长度  		默认为9
				-d  数字位数 	默认为2



--------------------------------------------------------------------------------------------------------------------------

磁盘管理
			fdisk  				查看管理磁盘分区表 				format disk
			sfdisk 				查看管理磁盘分区表 				sfdisk
			cfdisk 
			parted 				GPT分区查看管理 				Partitioned
			mkfs  				创建文件系统					Make file system
			mke2fs  			创建ext 文件系统 				Make ext file system
			mkfs.ext2      		创建ext2文件系统 				Make file system ext2
			mkfs.ext3     		创建ext3文件系统 				Make file system ext3
			mkfs.ext4 			创建ext4文件系统 				Make file system ext4
			mkfs.xfs 			创建xfs 文件系统 				Make file system xfs
			
			e2label 			获取或设置ext分区的卷标  				ext2 label
			lsblk 				列出所有可用块设备的信息 				list block devices
			blkid 				对设备上所采用文件系统类型进行查询 		block id

			df: 				显示磁盘使用情况 				disk free 
			du: 				显示目录或文件的大小   			Disk usage
			dd 					转换和复制文件和文件系统 		disk dump
			mount 				挂载分区或文件系统 				mount
			umount 				卸载分区或文件系统 		 		unmount
			mountpoint
			fsck：File system check
			mkswap
			swapon
			swapoff
			free 				显示内存使用情况


/sbin/mke2fs
/sbin/mkfs.ext2
/sbin/mkfs.ext3
/sbin/mkfs.ext4


	块设备文件  		存取单位"块" 		硬盘      	block
	字符设备文件  	存取单位"字符"		键盘 鼠标    char


	硬盘接口类型：
		并行
			IDE 	133MB/s
			SCSI 	640MB/s


		串行
			SATA 	6Gbps
			SAS 	6Gbps
			USB 	480MB/s

	接口命名：
		ide   					/dev/hd
		sata，scsi，sas，usb  	/dev/sa

		不同设备a..z

		同一设备不同分区
		1,2,3....


	0磁道0扇区 512byte

	446  BootLoader
	54   分区表
	2    校验码55AA

	分区，格式化，挂载

	分区管理工具：
	fdisk 	最多15个分区
		-l
		
		查看内核是否已识别新的分区
		cat /proc/partitions  

		通知内核重新读取硬盘分区表
		partx -a /dev/DEVICE
			  -n M:N 

		kpartx -a /dev/DEVICE
			   -f  	:force


		centos5 :partprobe

			partprobe [/dev/DEVICE]


	parted
	sfdisk
parted的操作都是实时

	文件系统：
		ext2 ext3 ext4 xfs btrfs
		swap 交换分区
		iso9660 光盘
		vfat fat32 ntfs  Windows
		nfs cifs  网络文件系统
		smbfs
		gfs2  ocfs2  集群文件系统
	
	mke2fs

	mkfs.ext2
	mkfs.ext3
	mkfs.ext4

	mount

	umount

	dd

	df

	du
	
	lsblk

	blkid

df 	查看已挂载磁盘的总容量、使用容量、剩余容量等
	-h
	-m
	-k
	-i
	-b


du 	查看某个目录或文件所占空间大小.
	-b
	-k
	-m
	-h 	
	-c 	最后加总
	-s 	只列出总和



fdisk
	-l
	fdisk /dev/sda


mke2fs, 
mkfs.ext2, 
mkfs.ext3, 
mkfs.ext4
‘-b’ 分区时设定每个数据区块占用空间大小，目前支持1024,2048 以及4096 bytes 每个块。
‘-i’ 设定inode 的大小
‘-N’ 设定inode 数量，有时使用默认的inode 数不够用，所以要自定设定inode 数量。
‘-c’ 在格式化前先检测一下磁盘是否有问题，加上这个选项后会非常慢
‘-L’ 预设该分区的标签label
‘-j’ 建立ext3 格式的分区，如果使用mkfs.ext3 就不用加这个选项了
‘-t’ 用来指定什么类型的文件系统，可以是ext2, ext3 也可以是ext4.

e2label  用来查看或修改分区的标签
	e2label /dev/sdb5
	e2label /dev/sdb5 TEST123


mount
	mount /dev/cdrom /media
mount -o      options device directory
          Option：Description
          async：允许文件系统异步的输入与输出
          auto：Allows the file system to be mounted automatically using the mount -a command.
          defaults：Provides an alias for async,auto,dev,exec,nouser,rw,suid.
          exec：允许二进制文件执行
          loop：把镜像文件回环设备挂载
          noauto：Default behavior disallows the automatic mount of the file system using the mount -a command.
          noexec：不允许二进制文件执行
          nouser：禁止普通用户mount与umount
          remount：重新挂载
          ro：只读
          rw：允许读写
          user： 允许普通用户mount与umount
          acl：访问控制列表  
          EXT4:选项
               刷新cache时间:ext3,ext4
          commit=nsec文件系统CACHE刷新时间
          stripe= 条带大小（以block为单位）
          delalloc 开启延时块分配
          nodelalloc 禁止延时块分配
          barrier 开启write barrier
          nobarrier 禁止write barrier
          journal_dev=devnum (外部日志设备的设备号，由主次设备号组成)
         
模式：
          data=writeback 性能，高; 写回模式，先写metadata(代表日志),后写data
          data=ordered   性能，中； 命令模式，[先写data,后写metadata]==事务，最后写 metadata journal
          data=journal   性能，低： 日志模式， 先日志(metadata journal,data journal)，后数据(metadata,data)

mount -o ro,loop Fedora-14-x86_64-Live-Desktop.iso /media/cdrom
umount
	umount /dev/cdrom





cat /etc/fstab 

#
# /etc/fstab
# Created by anaconda on Mon Mar 20 02:08:51 2017
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
UUID=1cc6ae05-b3b8-4b40-8679-30cc36db0d36 /                       ext4    defaults        1 1
UUID=9e04b450-fefa-4f69-93af-91082e075358 /boot                   ext4    defaults        1 2
UUID=e4da9c7e-719e-4c67-83fd-6a81f77cb606 /home                   ext4    defaults        1 2
UUID=fb271cce-6b55-476e-bd61-b3b00351d18c swap                    swap    defaults        0 0
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0



这个文件是系统启动时，需要挂载的各个分区。
第一列就是分区的标识，可以写分区的LABEL，也可以写分区的UUID(等会阿铭会着重讲一下这个概念)，当然也可以写分区名(/dev/sda1)；
第二列是挂载点；
第三列是分区的格式；
第四列则是mount 的一些挂载参数， 等下会详细介绍一下有哪些参数， 一般情况下， 直接写
defaults 即可；第五列的数字表示是否被dump 备份，是的话这里
就是1，否则就是0；第六列是开机时是否自检磁盘。1，2 都表示
检测，0 表示不检测，在Redhat/CentOS 中，这个1，2 还有个
说法，/ 分区必须设为1，而且整个fstab 中只允许出现一个1，这
里有一个优先级的说法。1 比2 优先级高，所以先检测1，然后再
检测2，如果有多个分区需要开机检测那么都设置成2 吧，1 检测
完了后会同时去检测2。下面该说说第四列中常用到的参数了。
“async/sync” : async 表示和磁盘和内存不同步，系统每隔一段时
间把内存数据写入磁盘中，而sync 则会时时同步内存和磁盘中数
据；
“auto/noauto” : 开机自动挂载/不自动挂载；
“default” : 按照大多数永久文件系统的缺省值设置挂载定义，它包
含了rw, suid, dev, exec, auto, nouser, async
“ro” : 按只读权限挂载 ；
“rw” : 按可读可写权限挂载 ；
“exec/noexec” : 允许/不允许可执行文件执行，但千万不要把根
分区挂载为noexec，那就无法使用系统了，连mount 命令都无法
使用了，这时只有重新做系统了；
“user/nouser” : 允许/不允许root 外的其他用户挂载分区，为了
安全考虑，请用nouser ；
“suid/nosuid” : 允许/ 不允许分区有suid 属性， 一般设置
nosuid ；
“usrquota” : 启动使用者磁盘配额模式，磁盘配额相关内容在后续
章节会做介绍；
“grquota” : 启动群组磁盘配额模式；
学完这个/etc/fstab 后，我们就可以自己修改这个文件，增加一行
来挂载新增分区。例如，阿铭增加了这样一行:
LABEL=TEST /newdir ext4 defaults
0 0
然后卸载掉刚才我们已经挂载的/dev/sdb5


lsblk

blkid
	# blkid
	# blkid /dev/sda
	# blkid -s UUID
	# blkid -s UUID /dev/sda1
	# blkid -o list
	blkid /dev/sdb5
	mount UUID="c61117ca-9176-4d0b-be4d-1b0f434359a7" /newdir

dd
	dd if=/dev/zero of=/tmp/sod bs=1M count=128

mkswap
	mkswap -f /tmp/sod
	swapon /tmp/sod

quoto 

--------------------------------------------------------------------------------------------------------------

tar cxvf xx.tar.gz xx
	
	-C
	-tf 可以查看包或者压缩包的文件列表
	-c	建立一个tar包或者压缩文件包
	-f	后面跟文件名，压缩时跟―-f 文件名‖，意思是压缩后的文件名为filename，解压时跟―-f 文件名‖，
	-v	可视化
	-x	解包或者解压缩
	-z	同时用gzip压缩
	-j	同时用bzip2压缩
	-J	同时用xz压缩
	-p: 使用原文件的属性，压缩前什么属性压缩后还什么属性。（不常用） 
	-P: 可以使用绝对路径。（不常用）

	tar zcvf ssss.tar.gz ssss
	tar jcvf ssss.tar.bz2 ssss

	tar Jxvf ssss.tar.xz

	tar -tf test111.tar.gz

gzip
	gzip [-d#] filename 其中#为1-9 的数字
	“-d” : 解压缩时使用
	“-#” : 压缩等级，1 压缩最差，9 压缩最好，6 为默认

bzip2 [-dz] filename
bzip2 只有两个选项需要你掌握。
“-d” : 解压缩
“-z” : 压缩

xz
	-d 
	-x 

zip/unzip
	zip sss.zip sss
	zip -r sss.zip sss
	unzip sss.zip

----------------------------------------------------------------------------------------------------------------------------
程序包管理
	rpm
	yum
	apt-get
	源码编译

	程序源代码 --->预处理 ---> 编译 ---> 汇编 ---> 链接

	静态编译
	共享编译  .so

	API
	ABI

		系统级开发
		C
		C++

		应用级开发
		Java
		Python

	软件包分类：
	源码包
	二进制包（rpm包、系统默认包）

	源码包-优点：
① 开源。可修改源代码
② 可自由选择所需的功能
③ 软件是通过编译安装，与操作系统匹配度高，稳定性和效率也高
④ 卸载方便。直接删除安装目录
源码包-缺点：
① 安装过程步骤相对较多，安装大型软件集合环境（如：LAMP）时容易出错，排错花费比较多精力
② 编译过程时间较长，安装过程比二进制安装时间更长

二进制包-优点：
① 包管理系统简单，通过相对较少的命令即可对包进行安装、升级、查询、卸载
② 安装速度比源码包安装要快很多

二进制包-缺点：
① 经过编译，不再可看到源代码
② 功能选择没有源码包灵活
③ 依赖性。安装某个软件包A，需要先安装软件包B，B又可能需要依赖C，此时需要先安装C-->B-->A




	二进制应用程序的组成部分：
		二进制文件，库文件，配置文件，帮助文件

	程序包管理器：
		Debian: 	.deb 	dpt   apt-get
		CentOS: 	.rpm 	rpm   yum


	源码： name.Version.tar.gz
			Version：主版本号.次版本号.发布版本号

	rpm命名方式：
			name-Version-Arch.rpm
			Version：主版本号.次版本号.发布版本号
			Arch:release.arch

			bash-4.1.2-48.el6.x86_64
			python-2.6.6-66.el6_8.x86_64

	字符名称	含义
	httpd-2.2.15-15.el6.centos.1.i686.rpm	软件的包全名
	httpd	软件的包名
	2.2.15	软件的版本
	15	软件的发布次数
	el6.centos	适合的Linux平台
	i686	适合的硬件平台
	rpm	rpm包扩展名


1）包全名、包名-使用场景
① 若操作的包是系统中没有安装过的软件包时，使用包全名（注意路径）
② 若操作的包是系统中已安装过的软件包时，则使用包名（搜索的是 /var/lib/rpm/ 中的数据库）


	testapp：拆包
		testapp-Version-Arch.rpm 	主包
		testapp-devel-Version-Arch.rpm 支包
		testapp-testing-Version-Arch.rpm 

	包之间依赖关系：

		yum 包管理前端工具

	查看二进制文件依赖库文件
		ldd
			-v
	管理及查看本机已加载的库文件
		ldconfig
			/sbin/ldconfig -p

		配置文件：
			/etc/ld.so.conf 
			/etc/ld.so.conf.d/*.conf

		缓存文件/etc/ld.so.cache

	ldconfig几个需要注意的地方 
		1. 往/lib和/usr/lib里面加东西，是不用修改/etc/ld.so.conf的，但是完了之后要调一下ldconfig，不然这个library会找不到 
		2. 想往上面两个目录以外加东西的时候，一定要修改/etc/ld.so.conf，然后再调用ldconfig，不然也会找不到 
			比如安装了一个MySQL到/usr/local/mysql，mysql有一大堆library在/usr/local/mysql/lib下面，这时 就需要在/etc/ld.so.conf下面加一行/usr/local/mysql/lib，保存过后ldconfig一下，新的library才能在 程序运行时被找到。 
		3. 如果想在这两个目录以外放lib，但是又不想在/etc/ld.so.conf中加东西（或者是没有权限加东西）。那也可以，就是export一个全局变 量LD_LIBRARY_PATH，然后运行程序的时候就会去这个目录中找library。一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时 候使用。 
		4. ldconfig做的这些东西都与运行程序时有关，跟编译时一点关系都没有。编译的时候还是该加-L就得加，不要混淆了。 
		5. 总之，就是不管做了什么关于library的变动后，最好都ldconfig一下，不然会出现一些意想不到的结果。不会花太多的时间，但是会省很多的事。


RPM：Red hat package manager
dpkg：Debian package manager
apt：Advanced package tool（Debian或基于Debian的发行版中提供）

	rpm /bin/rpm
		-i  安装（install）
        -v  显示详细信息（verbose）
        -h  显示进度（hash）
        --nodeps    不检测依赖性（为保证功能正常，实际工作中安装时不建议使用此命令）
        -e  卸载（erase）
        -U  升级（upgrade）
        -q  查询（query）
        	-a  所有（all）
        	-i  软件信息（information）
            -p  未安装包信息（package）
            -l  列表（list）
            -f  文件（file）
					-qa 查询所有已安装的rpm包
					-qi查询软件包的详细信息
					-qf查询某个系统文件属于归属的包
					-ql查询包中文件的安装路径
					-qc
					-qd
		-V 校验指定rpm包中的文件（verify）
		校验作用：通过与官网的程序包比对，检查是否有被修改or其他差异性

			验证输出结果中的8个信息含义：
			S ==> 文件大小，是否改变
			M ==> 文件的类型or权限（rwx）
			5 ==> 文件md5校验，文件内容是否改变（完整性检验）
			D ==> 设备的主从代码
			L ==> 文件路径
			U ==> 文件的属主（所有者）
			G ==> 文件的属组
			T ==> 文件的修改时间

			文件类型：
			c ==> 配置文件（config file）
			d ==> 普通文档（documentation）
			g ==> ghost文件（该文件不应该被rpm包所包含）
			L ==> 授权文件（license file）
			r ==> 描述文件（read me）
			PS：若包文件未被修改过，则校验不会输出任何信息；若校验输出异常提示，则表示对应包文件已被修改过


	
	rpm包默认安装路径（非必须）：

	路径	说明
	/etc/	配置文件安装目录
	/usr/bin/	可值的命令安装目录
	/usr/lib/	程序锁使用的函数库保存位置
	/usr/share/doc/	基本的软件使用手册保存位置
	/usr/share/man/	帮助文件保存位置



		--force
		--nodeps

		不要升级内核，新旧内核并存

	yum /usr/bin/yum

		info
		list
		provides  */命令
		search
		repolist
		install
		localinstall
		update
		upgrade
		remove
		clean
			clean all
		grouplist
		groupinstall
		groupupdate
		groupremove

		--downloadonly 
		--downloaddir=

	本地yum源
	cp -r /etc/yum.repos.d /etc/yum.repos.d.bak
	rm -rf /etc/yum.repos.d/*
	vim dvd.repo 

		[dvd]
		name=centos software repo
		baseurl=file:///mnt/chrom
		baseurl=http://download.fedoraproject.org/pub/epel/6/$basearch
		enabled=1
		gpgcheck=1
		gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6
	

rpm 
	-i
	-v
	-h
	-e
	-U
	-q
	rpm命令是RPM软件包的管理工具。rpm原本是Red Hat Linux发行版专门用来管理Linux各项套件的程序，
	由于它遵循GPL规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM套件管理方式的出现，
	让Linux易于安装，升级，间接提升了Linux的适用度。
	
	rpm -ivh sssssssssssssss.rpm
	--force: 强制安装，即使覆盖属于其他包的文件也要安装。 
	--nodeps :当要安装的rpm包依赖其他包时，即使其他包没有安装，也要安装这个包
	rpm -Uvh filename
	rpm -e filename

	rpm -q vim-enhanced
	rpm -qa 
	rpm -qi	vim-enhanced	得到一个已安装rpm包的相关信息
	rpm -ql vim-enhanced	列出一个rpm包安装的文件
	rpm -qf /usr/lib/libjpeg.so 列出某一个文件属于哪个rpm包

语法
rpm(选项)(参数)
选项
-a：查询所有套件；
-b<完成阶段><套件档>+或-t <完成阶段><套件档>+：设置包装套件的完成阶段，并指定套件档的文件名称；
-c：只列出组态配置文件，本参数需配合"-l"参数使用；
-d：只列出文本文件，本参数需配合"-l"参数使用；
-e<套件档>或--erase<套件档>：删除指定的套件；
-f<文件>+：查询拥有指定文件的套件；
-h或--hash：套件安装时列出标记；
-i：显示套件的相关信息；
-i<套件档>或--install<套件档>：安装指定的套件档；
-l：显示套件的文件列表；
-p<套件档>+：查询指定的RPM套件档；
-q：使用询问模式，当遇到任何问题时，rpm指令会先询问用户；
-R：显示套件的关联性信息；
-s：显示文件状态，本参数需配合"-l"参数使用；
-U<套件档>或--upgrade<套件档>：升级指定的套件档；
-v：显示指令执行过程；
-vv：详细显示指令执行过程，便于排错。
参数
软件包：指定要操纵的rpm软件包。

实例
如何安装rpm软件包

rpm软件包的安装可以使用程序rpm来完成。执行下面的命令：

rpm -ivh your-package.rpm
其中your-package.rpm是你要安装的rpm包的文件名，一般置于当前目录下。

安装过程中可能出现下面的警告或者提示：

... conflict with ...
可能是要安装的包里有一些文件可能会覆盖现有的文件，缺省时这样的情况下是无法正确安装的可以用rpm --force -i强制安装即可

... is needed by ...
... is not installed ...
此包需要的一些软件你没有安装可以用rpm --nodeps -i来忽略此信息，也就是说rpm -i --force --nodeps可以忽略所有依赖关系和文件问题，
什么包都能安装上，但这种强制安装的软件包不能保证完全发挥功能。

如何安装.src.rpm软件包

有些软件包是以.src.rpm结尾的，这类软件包是包含了源代码的rpm包，在安装时需要进行编译。这类软件包有两种安装方法：

方法一：

rpm -i your-package.src.rpm
cd /usr/src/redhat/SPECS
rpmbuild -bp your-package.specs             #一个和你的软件包同名的specs文件
cd /usr/src/redhat/BUILD/your-package/      #一个和你的软件包同名的目录
./configure                                 #这一步和编译普通的源码软件一样，可以加上参数
make
make install
方法二：

rpm -i you-package.src.rpm
cd /usr/src/redhat/SPECS
前两步和方法一相同

rpmbuild -bb your-package.specs       #一个和你的软件包同名的specs文件
这时在/usr/src/redhat/RPM/i386/（根据具体包的不同，也可能是i686,noarch等等）在这个目录下，有一个新的rpm包，这个是编译好的二进制文件。

执行rpm -i new-package.rpm即可安装完成。

如何卸载rpm软件包

使用命令rpm -e包名，包名可以包含版本号等信息，但是不可以有后缀.rpm，比如卸载软件包proftpd-1.2.8-1，可以使用下列格式：

rpm -e proftpd-1.2.8-1
rpm -e proftpd-1.2.8
rpm -e proftpd-
rpm -e proftpd
不可以是下列格式：

rpm -e proftpd-1.2.8-1.i386.rpm
rpm -e proftpd-1.2.8-1.i386
rpm -e proftpd-1.2
rpm -e proftpd-1
有时会出现一些错误或者警告：

... is needed by ...
这说明这个软件被其他软件需要，不能随便卸载，可以用rpm -e --nodeps强制卸载

如何不安装但是获取rpm包中的文件

使用工具rpm2cpio和cpio

rpm2cpio xxx.rpm | cpio -vi
rpm2cpio xxx.rpm | cpio -idmv
rpm2cpio xxx.rpm | cpio --extract --make-directories
参数i和extract相同，表示提取文件。v表示指示执行进程，d和make-directory相同，表示根据包中文件原来的路径建立目录，m表示保持文件的更新时间。

如何查看与rpm包相关的文件和其他信息

下面所有的例子都假设使用软件包mysql-3.23.54a-11

1、我的系统中安装了那些rpm软件包。

rpm -qa 讲列出所有安装过的包
如果要查找所有安装过的包含某个字符串sql的软件包

rpm -qa | grep sql
2、如何获得某个软件包的文件全名。

rpm -q mysql
可以获得系统中安装的mysql软件包全名，从中可以获得当前软件包的版本等信息。这个例子中可以得到信息mysql-3.23.54a-11

3、一个rpm包中的文件安装到那里去了？

rpm -ql 包名
注意这里的是不包括.rpm后缀的软件包的名称，也就是说只能用mysql或者mysql-3.23.54a-11而不是mysql-3.23.54a-11.rpm。如果只是想知道可执行程序放到那里去了，也可以用which，比如：

which mysql
4、一个rpm包中包含那些文件。

一个没有安装过的软件包，使用rpm -qlp ****.rpm
一个已经安装过的软件包，还可以使用rpm -ql ****.rpm
5、如何获取关于一个软件包的版本，用途等相关信息？

一个没有安装过的软件包，使用rpm -qip ****.rpm
一个已经安装过的软件包，还可以使用rpm -qi ****.rpm
6、某个程序是哪个软件包安装的，或者哪个软件包包含这个程序。

rpm -qf `which 程序名`    #返回软件包的全名
rpm -qif `which 程序名`   #返回软件包的有关信息
rpm -qlf `which 程序名`   #返回软件包的文件列表
注意，这里不是引号，而是`，就是键盘左上角的那个键。也可以使用rpm -qilf，同时输出软件包信息和文件列表。

7、某个文件是哪个软件包安装的，或者哪个软件包包含这个文件。

注意，前一个问题中的方法，只适用与可执行的程序，而下面的方法，不仅可以用于可执行程序，也可以用于普通的任何文件。前提是知道这个文件名。首先获得这个程序的完整路径，可以用whereis或者which，然后使用rpm -qf例如：

whereis ftptop
ftptop: /usr/bin/ftptop /usr/share/man/man1/ftptop.1.gz

rpm -qf /usr/bin/ftptop
proftpd-1.2.8-1

rpm -qf /usr/share/doc/proftpd-1.2.8/rfc/rfc0959.txt
proftpd-1.2.8-1



yum
	yum list			所有可用的rpm包
	yum search vim`		搜索一个包
	yum install vim		安装一个包
	yum remove [-y] [rpm包名]	卸载一个包
	yum update [-y] [rpm包]		升级一个rpm包 命令 
	yum install -y epel-release

	(1) 挂载光盘 [root@localhost ~]# mount /dev/cdrom /mnt 
	(2) 删除/etc/yum.repos.d目录所有的repo文件 保险起见，我们先备份一下/etc/yum.repos.d目录 
	[root@localhost ~]# cp -r /etc/yum.repos.d /etc/yum.reps.d.bak 
	[root@localhost ~]# rm -rf /etc/yum.repos.d/* 
	(3) 创建新文件dvd.repo 
	[root@localhost ~]# vim /etc/yum.repos.d/dvd.repo 
	//加入以下内容： 
	[dvd] 
	name=install dvd 
	baseurl=file:///mnt 
	enabled=1 
	gpgcheck=0 
	(4) 刷新 repos 生成缓存
	[root@localhost ~]# yum makecache 
	然后就可以使用yum命令安装你所需要的软件包了。
	如果不想使用本地yum源，需要删除掉这个/etc/yum.repos.d/dvd.repo文件，
	然后恢复原来的配置文件。

yum如何下载rpm包到本地
yum install -y yum-plugin-downloadonly.noarch
yum install 包名 -y --downloadonly --downloaddir=/usr/local/src

源码编译安装
	yum install gcc gcc-c++ automake autoconf

	./configure
	make
	make install


---------------------------------------------------------------------------------------------------------------------
	网络管理：

	ifcfg

	ifconfig

    ifup

    ifdown

    arp

    ping

    netstat

    route

    dhclient

    telnet

    ssh
    	ssh-keygen

    	ssh-copy-id

    scp

    rsync

    curl

    wget

    mail

    lftp

    ip - show / manipulate routing, devices, policy routing and tunnels

		SYNOPSIS
       ip [ OPTIONS ] OBJECT { COMMAND | help }

       OBJECT := { link | addr | addrlabel | route | rule | neigh | tunnel | maddr | mroute | monitor }

       OPTIONS := { -V[ersion] | -s[tatistics] | -r[esolve] | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] }

       ip link set DEVICE { up | down | arp { on | off } |
               promisc { on | off } |
               allmulticast { on | off } |
               dynamic { on | off } |
               multicast { on | off } |
               txqueuelen PACKETS |
               name NEWNAME |
               address LLADDR | broadcast LLADDR |
               mtu MTU |
               netns PID |
               alias NAME |
               vf NUM [ mac LLADDR ] [ vlan VLANID [ qos VLAN-QOS ] ] [ rate TXRATE ] [ spoofchk { on | off } ] |  }

       ip link show [ DEVICE ]

       ip addr { add | del } IFADDR dev STRING

       ip addr { show | flush } [ dev STRING ] [ scope SCOPE-ID ] [ to PREFIX ] [ FLAG-LIST ] [ label PATTERN ]


	网络地址不属于接口，而是属于内核

	ip link 
		show dev [DEVICE]

		set dev [DEVICE] up|down

	ip addr

       ip addr { add | del } IFADDR dev STRING

       ip addr { show | flush } [ dev STRING ] [ scope SCOPE-ID ] [ to PREFIX
               ] [ FLAG-LIST ] [ label PATTERN ]

       IFADDR := PREFIX | ADDR peer PREFIX [ broadcast ADDR ] [ anycast ADDR ]
               [ label STRING ] [ scope SCOPE-ID ]

       SCOPE-ID := [ host | link | global | NUMBER ]


ss

tc

--------------------------------------------------------------------------------------------------------------------------------

系统及进程管理
	ps 		process status(进程状态，类似于windows的任务管理器)
	pstree
	pgrep
	pidof
	w
	who
	whoami

	last

	lastb

	dmesg 

	lastlog

	lslogins


	free

	top

	atop

	htop

	watch

	service

	chkconfig

	time

	runlevel

	crontab

	at

	nohup

	kill

	pkill

	killall

	pgrep

	ulimit

	lsof

关机及重启
	shutdown
	poweroff
	halt
	init
	reboot


-------------------------------------------------------------------------------------------------------------------	
归档压缩

tar

gzip

gunzip 

zcat

bzip2

bunzip2

xz

zip

unzip




----------------------------------------------------------------------------------------------------------------------

文档字符

	dos2unix 

	unix2dos

	col
	  -b

	iconv


history
	-c 
	
clear

alias 

analias 


jobs

fg

bg


ps 

psttee

kill

pkill

killall

set

unset

reset

env



cut 
	-b
	-c
	-d
	-f
	-d
	-f
	-c 后面可以是1个数字n，也可以是一个区间n1-n2，还可以是多个数字n1,n2,n3
	cat /etc/passwd |cut -d ':' -f 1 |head -n5
	 head /etc/passwd|cut -c2
	 head /etc/passwd|cut -c1-5
	 head /etc/passwd|cut -c1,3,5,7

paste
	-d
	-s
sort
	-n
	-i
	-r
	-o
	-u
	-k
	-t
语法： 
sort [-t 分隔符] [-kn1,n2] [-nru] 这里的n1 < n2 -t 分隔符 ：作用跟cut的-d一个意思 
	-n ：使用纯数字排序 
	-r ：反向排序 
	-u ：去重复 
	-kn1,n2 ：由n1区间排序到n2区间，可以只写-kn1，即对n1字段排序
	sort命令是帮我们依据不同的数据类型进行排序，其语法及常用参数格式：
　　sort [-bcfMnrtk][源文件][-o 输出文件]
补充说明：sort可针对文本文件的内容，以行为单位来排序。
sort -n 针对数字排序，如果排序的对象是英文字母，则会按0处理。

参　　数：
  -b   忽略每行前面开始出的空格字符。
  -c   检查文件是否已经按照顺序排序。
  -f   排序时，忽略大小写字母。
  -M   将前面3个字母依照月份的缩写进行排序。
  -n   依照数值的大小排序。
  -o<输出文件>   将排序后的结果存入指定的文件。
  -r   以相反的顺序来排序。
  -t<分隔字符>   指定排序时所用的栏位分隔字符。
  -k  选择以哪个区间进行排序。
	head /etc/passwd|sort	如果sort不加任何选项，则从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。
	head -n5 /etc/passwd |sort -t: -k3,5 -r		
	-k3,5 表示从第3到第5区域间的字符串排序，-r表示反向排序 如果把-nu一起用，sort会把文档中的字母看成0。

	cut -d: -f1 /etc/passwd |sort -n -u	就只剩第一行了，因为它把所有的字符串都看成是0了。

	
	
wc
	-l
	-w
	-m

uniq
	-c
uniq
	使用uniq 的前提是需要先给文件排序，否则不管用。
	-c	在每列旁边显示该行重复出现的次数；
	-d或--repeated：仅显示重复出现的行列； 
	-f<栏位>或--skip-fields=<栏位>：忽略比较指定的栏位； 
	-s<字符位置>或--skip-chars=<字符位置>：忽略比较指定的字符； 
	-u或——unique：仅显示出一次的行列； 
	-w<字符位置>或--check-chars=<字符位置>：指定要比较的字符。

	uniq sss.txt
	uniq -c sss.txt
	uniq -d sss.txt
	uniq -u sss.txt

	
	
tr 	替换字符，常用来处理文档中出现的特殊符号，如DOS 文档中出现的^M 符号。常用的选项有两个：
    -d ：删除某个字符，-d 后面跟要删除的字符
    -s ：把重复的字符去掉
	最常用的就是把小写变大写: tr ‘[a-z]’ ‘[A-Z]’
	head -n2 /etc/passwd |tr '[a-z]' '[A-Z]'
tr
	tr用于替换字符，常用来处理文档中出现的特殊符号，
	如DOS文档中出现的^M符号。
	常用的选项有两个： 
	-d：删除某个字符，-d后面跟要删除的字符 
	-s：把重复的字符去掉 
	最常用的就是把小写变大写: tr ‗[a-z]‘ ‗[A-Z]‘

	实例：

、将文件file中出现的"abc"替换为"xyz"
 
# cat file | tr "abc" "xyz" > new_file
 
【注意】这里，凡是在file中出现的"a"字母，都替换成"x"字母，"b"字母替换为"y"字母，"c"字母替换为"z"字母。而不是将字符串"abc"替换为字符串"xyz"。
 
2、使用tr命令“统一”字母大小写
（小写 --> 大写）
# cat file | tr [a-z] [A-Z] > new_file
（大写 --> 小写）
# cat file | tr [A-Z] [a-z] > new_file
 
3、把文件中的数字0-9替换为a-j
 
# cat file | tr [0-9] [a-j] > new_file

4、删除文件file中出现的"Snail"字符
 
# cat file | tr -d "Snail" > new_file
 
【注意】这里，凡是在file文件中出现的'S','n','a','i','l'字符都会被删除！而不是紧紧删除出现的"Snail”字符串。
 
5、删除文件file中出现的换行'\n'、制表'\t'字符
 
# cat file | tr -d "\n\t" > new_file
 
不可见字符都得用转义字符来表示的，这个都是统一的。
 
6、删除“连续着的”重复字母，只保留第一个
 
# cat file | tr -s [a-zA-Z] > new_file
 
7、删除空行
 
# cat file | tr -s "\n" > new_file
 
8、删除Windows文件“造成”的'^M'字符
 
# cat file | tr -d "\r" > new_file
或者
# cat file | tr -s "\r" "\n" > new_file
 
【注意】这里-s后面是两个参数"\r"和"\n"，用后者替换前者
 
9、用空格符\040替换制表符\011
 
# cat file | tr -s "\011" "\040" > new_file
 
10、把路径变量中的冒号":"，替换成换行符"\n"
 
# echo $PATH | tr -s ":" "\n"

	将输入字符由大写转换为小写： 
	echo "HELLO WORLD" | tr 'A-Z' 'a-z' 
	hello world 
	'A-Z' 和 'a-z'都是集合，集合是可以自己制定的，
	例如：'ABD-}'、'bB.,'、'a-de-h'、'a-c0-9'都属于集合，
	集合里可以使用'\n'、'\t'，可以可以使用其他ASCII字符。 
	使用tr删除字符： echo "hello 123 world 456" | tr -d '0-9' 
	hello world 
	将制表符转换为空格： 
	cat text | tr '\t' ' ' 
	字符集补集，从输入文本中将不在补集中的所有字符删除： 
	echo aa.,a 1 b#$bb 2 c*/cc 3 ddd 4 | tr -d -c '0-9 \n' 1 2 3 4 
	此例中，补集中包含了数字0~9、空格和换行符\n，所以没有被删除，其他字符全部被删除了。 
	用tr压缩字符，可以压缩输入中重复的字符： 
	echo "thissss is a text linnnnnnne." | tr -s ' sn' 
	this is a text line. 
	巧妙使用tr做数字相加操作： echo 1 2 3 4 5 6 7 8 9 | xargs -n1 | echo $[ $(tr '\n' '+') 0 ] 
	删除Windows文件“造成”的'^M'字符： 
	cat file | tr -s "\r" "\n" > new_file 
	或 cat file | tr -d "\r" > new_file

	
	

tee 	后跟文件名，类似与重定向 “>”, 但是比重定向多了一个功能，在把文件写入后面所跟的文件中的同时，还显示在屏幕上。
		tee 常用语管道符 “|” 后。

		echo "aaaaaaaaaaaaaaaaaaaaaaaaaaa" |teetestb.txt
			aaaaaaaaaaaaaaaaaaaaaaaaaaa
tee
用于将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的stdin。简单的说就是把数据重定向到给定文件和屏幕上

tee命令，后跟文件名，类似与重定向 ―>‖，但是比重定向多了一个功能，
在把文件写入后面所跟的文件中的同时，还显示在屏幕上。
tee 常用语管道符―|后。
	-a或--append 　附加到既有文件的后面，而非覆盖它．
　	-i-i或--ignore-interrupts 　忽略中断信号。
	
	cat 1.txt | tee 3.txt 
	cat 1.txt | tee -a 3.txt 
	echo 12345 | tee	 使用tee命令重复输出字符串
	echo 12345 | tee -
	echo 12345 | tee --
	
	


split	切割文档，常用选项：
	-b ：依据大小来分割文档，单位为byte
	如果split 不指定目标文件名，则会以xaa xab... 这样的文件名
	来存取切割后的文件。当然我们也可以指定目标文件名：
	split -b500 passwd 123
	split_dir]# ls
	123aa 123ab 123ac passwd
	-l ：依据行数来分割文档
split
	split命令可以将一个大文件分割成很多个小文件，有时需要将文件分割成更小的片段，
	比如为提高可读性，生成日志等。 
	-a : 数字位数
	选项 -b：值为每一输出档案的大小，单位为 byte。 
	-C：每一输出档中，单行的最大 byte 数。 
	-d：使用数字作为后缀。 
	-l：值为每一输出档的列数大小。 
	
	实例 生成一个大小为100KB的测试文件： 
	[root@localhost split]# dd if=/dev/zero bs=100k count=1 of=date.file 
	1+0 records in 
	1+0 records out 
	102400 bytes (102 kB) copied, 0.00043 seconds, 238 MB/s 
	使用split命令将上面创建的date.file文件分割成大小为10KB的小文件： 
	[root@localhost split]# split -b 10k date.file 
	[root@localhost split]# ls 
	date.file xaa xab xac xad xae xaf xag xah xai xaj 
	文件被分割成多个带有字母的后缀文件，如果想用数字后缀可使用-d参数，同时可以使用-a length来指定后缀的长度： [root@localhost split]# split -b 10k date.file -d -a 3 
	[root@localhost split]# ls 
	date.file x000 x001 x002 x003 x004 x005 x006 x007 x008 x009 
	为分割后的文件指定文件名的前缀： 
	[root@localhost split]# split -b 10k date.file -d -a 3 split_file 
	[root@localhost split]# ls 
	date.file split_file000 split_file001 split_file002 split_file003 split_file004 split_file005 split_file006 split_file007 split_file008 split_file009 
	使用-l选项根据文件的行数来分割文件，例如把文件分割成每个包含10行的小文件： 
	split -l 10 date.file

	split -b 100m 1111.log (按照字节分隔)
    split -l 1000000 1111.log(按照行数分隔


[root@localhost test]# more test
a
b
c
d
e
f
g


1.根据行拆分

每3行拆分成一个文件，拆分后的文件名以name开头，以数字作为后缀后缀长度为1

split -l 3 test -d -a 1 name

[root@localhost test]# ll
total 16
-rw-r--r--. 1 root root  6 Oct  9 19:12 name0
-rw-r--r--. 1 root root  6 Oct  9 19:12 name1
-rw-r--r--. 1 root root  2 Oct  9 19:12 name2
-rw-r--r--. 1 root root 14 Oct  9 19:07 test

2.按字节进行拆分

每三个字节拆分成一个文件，默认不加单位就是字节，也可以带单位比如KB,MB等

split -b 3 test -d -a 1 new

[root@localhost test]# ls -l new*
-rw-r--r--. 1 root root 3 Oct  9 19:13 new0
-rw-r--r--. 1 root root 3 Oct  9 19:13 new1
-rw-r--r--. 1 root root 3 Oct  9 19:13 new2
-rw-r--r--. 1 root root 3 Oct  9 19:13 new3
-rw-r--r--. 1 root root 2 Oct  9 19:13 new4



------------------------------------------------------------------------------------------------------------------------------

grep 
	--color=auto
	-i
	-c
	-n
	-v
	-o
	-w

	
	字符匹配：
	b
	word
	. 		匹配任意单个字符
	[]  匹配指定范围内的任意单个字符
	[-]
	[^]  匹配指定范围外的任意单个字符

	POSIX字符：
	[[:lower:]] 匹配任意小写字母
	[[:upper:]] 匹配任意大写字母
	[[:alpha:]] 匹配任意字母，不区分大小写
	[[:alnum:]] 匹配任意数字或字母，不区分大小写
	[[:space:]] 匹配任意空白字符（包括空格）
	[[:punct:]] 匹配所有标点符号
	[[:digit:]] 只匹配数字
	[[:graph:]] 匹配除了空格以外的字符
	[[:blank:]] 匹配空格或者制表符
	[[:print:]] 匹配任意可打印字符
	[[:xdigit:]] 匹配所有的十六进制数


	

	匹配次数
	* 匹配前面的字符任意次（前面的字符可以出现也可以不出现）
	.* 匹配任意长度的任意字符（用来匹配字符）
	\?	前面字符0次或1次 匹配前面的字符零次或一次
	\+ 前面字符1次或多次 匹配前面的字符至少一次
	\{m\}  指定匹配前面字符的次数
	\{m,\}  指定匹配前面的字符至少的次数，多则不限
	\{0,最多匹配次数\} 指定匹配前面的字符最多次数，也可没有
	\{m,n\} 指定匹配前面的的字符最少次数和最多次数
	

	位置锚定
	^  行首锚定，写在模式的最左侧；此字符后的任意内容必须出现在行首
	$  行尾锚定，写在模式的最右侧；此字符前的任意内容必须出现在行尾
	^$	空白行
	\<	\b	\bword	词首  词首锚定，用于单词模式的左侧；其后面的任意字符必须作为单词的首部出现
	\> \b 	word\b 	词尾  词尾锚定，用于单词模式的右侧；其前面的任意字符必须作为单词的尾部出现
	\<WORD\> 匹配整个单词
	\

	模式匹配

^PATTERNS  用于模式匹配整行
^$  匹配空行
^[[:space:]]*$  匹配用空格隔开的

	分组及引用
	\(\)	将一个或多个字符捆绑，作为一个整体引用.
	将一个或多个字符捆绑在一起，当做一个整体进行处理分组括号中的模式匹配到的内容会被正则表达式引擎记录与内部的变量中，
	这些变量的命名方式为：\1,\2,\3...
		\1	第一个.引用第一个左括号以及与之对应的右括号所包括的所有内容

	后向引用
	引用前面的分组括号中的模式所匹配到的字符，而非模式本身；被前面括号括起来的内容，后面可以使用一个字符将其引用
	+
	?
	|
	()

	
\|





grep [-cinvABC] 'word' filename 
	-c ：打印符合要求的行数
	-n ：在输出符合要求的行的同时连同行号一起输出 
	-v ：打印不符合要求的行 
	-A ：后跟一个数字（有无空格都可以），例如 –A2则表示打印符合要求的行以及下面两行 
	-B ：后跟一个数字，例如 –B2 则表示打印符合要求的行以及上面两行 
	-C ：后跟一个数字，例如 –C2 则表示打印符合要求的行以及上下各两行 
	-r : 会把目录下面所有的文件全部遍历 
	--color: 把匹配到的关键词用红色标识


	4）. * + ? 总结 
	. 表示任意一个字符（包括特殊字符） 
	* 表示零个或多个*前面的字符 
	.* 表示任意个任意字符（包含空行） 
	+ 表示1个或多个+前面的字符 
	？ 表示0个或1个?前面的字符 
	其中，+和? grep不支持，egrep才支持
	
	


reboot
shutdown
  -k
  -h now
  -r +5 "the system will be reboot"

poweroff
 
init
	
  
paste
  paste 1 3
  paste -d ":" 1 3
  paste -s 1 3
  ls /|paste -d " " - - -
  paste -d -s 1 3

cut
  -b  byte
  -c characters
  -d :
  -f

  who|cut -b 3-5,8
  who|cut -b 3-
  who|cut -b -3
  who|cut -b -

  cat /etc/passwd|head -n 5|cut -d : -f 1,3-5
  cat /etc/passwd|head -n 5|cut -d : -f -2



sort  依据不同的数据类型进行排序
  sort file.txt
  sort -n file  依照数值的大小排序
  sort -u file  在输出行中去除重复行
  sort -r file  以相反的顺序来排序
  sort -t file  指定排序时所用的栏位分隔字符
  sort -f file  忽略大小写
  sort -r file -o file  将排序后的结果存入指定的文件
  sort -k 2 -t ":" file  选择以哪个区间进行排序
  sort -k 2.2 -t ":" file
  sort -k 2.2 -k 3r -t ":" file


uniq   去除排序过的文件中的重复行，因此uniq经常和sort合用。
       也就是说，为了使uniq起作用，所有的重复行必须是相邻的。

i   ：忽略大小写字符的不同；
-c  ：进行计数
-u  ：只显示唯一的行
– c 显示输出中，在每行行首加上本行在文件中出现的次数。它可取代- u和- d选项。

– d 只显示重复行。

– u 只显示文件中不重复的各行。

– n 前n个字段与每个字段前的空白一起被忽略。一个字段是一个非空格、非制表符的字符串，彼此由制表符和空格隔开(字段从0开始编号)。

+n 前n个字符被忽略，之前的字符被跳过(字符从0开始编号)。

– f n 与- n相同，这里n是字段数。

– s n 与+n相同，这里n是字符数。

-c, --count              //在每行前加上表示相应行目出现次数的前缀编号  
 -d, --repeated          //只输出重复的行  
 -D, --all-repeated      //只输出重复的行，不过有几行输出几行  
 -f, --skip-fields=N     //-f 忽略的段数，-f 1 忽略第一段  
 -i, --ignore-case       //不区分大小写  
 -s, --skip-chars=N      //根-f有点像，不过-s是忽略，后面多少个字符 -s 5就忽略后面5个字符  
 -u, --unique            //去除重复的后，全部显示出来，根mysql的distinct功能上有点像  
 -z, --zero-terminated   end lines with 0 byte, not newline  
 -w, --check-chars=N      //对每行第N 个字符以后的内容不作对照

this is a test  
this is a test  
this is a test  
i am tank  
i love tank  
i love tank  
this is a test  
whom have a try  
WhoM have a try  
you  have a try  
i want to abroad  
those are good men  
we are good men


uniq -w 2 -c uniqtest
对每行第2个字符以后的内容不作检查，所以i am tank 根 i love tank就一样了。
uniq -u uniqtest
去重复的项，然后全部显示出来
uniq -d -c uniqtest 
uniq -d 只显示重复的行
uniq -D uniqtest
niq -D 只显示重复的行，并且把重复几行都显示出来。他不能和-c一起使用
uniq -f 1 -c uniqtest 
在这里those只有一行，显示的却是重复了，这是因为，-f 1 忽略了第一列，检查重复从第二字段开始的。
uniq -i -c uniqtest
检查的时候，不区分大小写
uniq -s 4 -c uniqtest
检查的时候，不考虑前4个字符，这样whom have a try 就和 you have a try 就一样了。


hello
world
friend
hello
world
hello

sort testfile | uniq -c   排序之后删除了重复行，同时在行首位置输出该行重复的次数

cat words | sort |uniq    排序文件，默认是去重

sort testfile | uniq -dc   仅显示存在重复的行，并在行首显示该行重复的次数



sort testfile | uniq -u   仅显示不重复的行



wc

统计文件里面有多少单词，多少行，多少字符。

wc
-l  ：仅列出行；
-w  ：仅列出多少字(英文单字)；
-m  ：多少字符；

wc /etc/passwd
40   45 1719 /etc/passwd

40是行数，45是单词数，1719是字节数


tr
  对来自标准输入的字符进行替换、压缩和删除。它可以将一组字符变成另一组字符



chmod
  ugoa   +-=   rwx
  chmod a+x free
  chmod u-x free

chown 
  -R
  -v

SUID  chmod u+s file    chmdo u-s file
SGID  chmod g+s file    chmod g-s file



date
	date +"%Y%m%d %H:%M:%S"
	date +%F
	date +%T
	date +%Y%m%d --date="-1 day"
	date +%Y%m%d         //显示现在天年月日
date +%Y%m%d --date="+1 day"  //显示后一天的日期
date +%Y%m%d --date="-1 day"  //显示前一天的日期
date +%Y%m%d --date="-1 month"  //显示上一月的日期
date +%Y%m%d --date="+1 month"  //显示下一月的日期
date +%Y%m%d --date="-1 year"  //显示前一年的日期
date +%Y%m%d --date="+1 year"  //显示下一年的日期

或者更简单点的  date=`date -d -${t}day '+%Y%m%d'` //为t为前几天


hwclock

ntpdate 





ln
	-s
	
Linux系统日常运维管理

w

cat /proc/cpuinfo | grep processor

cat /etc/centos-release
cat /etc/redhat-release
cat /etc/system-release

vmstat
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 260016  11792 104544    0    0    73     3   57   79  0  1 97  2  0

 (1) procs 显示进程相关信息 
 r：表示运行和等待cpu时间片的进程数。如果长期大于服务器cpu的个数，则说明cpu不够用了。 
 b：表示等待资源的进程数。比如，等待I/O、内存等，这列的值如果长时间大于1，则需要关注一下了

 (2) memory 内存相关信息 
 swpd：表示切换到交换分区中的内存数量 
 free：当前空闲的内存数量
 buff：缓冲大小，（即将写入磁盘的） 
 cache：缓存大小，（从磁盘中读取的）

 (3) swap 内存交换情况 
 si：由交换区写入到内存的数据量 
 so：由内存写入到交换区的数据量 
 
 (4) io 磁盘使用情况 
 bi：从块设备读取数据的量（读磁盘） 
 bo：从块设备写入数据的量（写磁盘） 
 
 (5) system 显示采集间隔内发生的中断次数 
 in：表示在某一时间间隔中观测到的每秒设备中断数 
 cs：表示每秒产生的上下文切换次数

 (6）CPU 显示cpu的使用状态 
 us：显示了用户下所花费cpu时间的百分比 
 sy：显示系统花费cpu时间百分比 
 id：表示cpu处于空闲状态的时间百分比 
 wa：表示I/O等待所占用cpu时间百分比 
 st：表示被偷走的cpu所占百分比（一般都为0，不用关注） 
 以上所介绍的各个参数中，我经常会关注r列，b列和wa列，三列代表的含义在上边说得已经很清楚。
 IO部分的bi以及bo也是要经常参考的对象。如果磁盘io压力很大时，这两列的数值会比较高。
 另外当si、so两列的数值比较高，并且在不断变化时，说明内存不够了，
 内存中的数据频繁交换到交换分区中，这往往对系统性能影响极大。

 vmstat 1 5		每隔一秒钟输出一次状态，共输出5次

 vmstat 1		每隔1秒输出一次状态且一直输出，除非我们按Ctrl + c结束


 top	动态查看负载

 于动态监控进程所占系统资源，每隔3秒变一次。它的特点是把占用系统资源（CPU，内存，磁盘IO等）
 最高的进程放到最前面。top命令打印出了很多信息，包括系统负载（loadaverage）、
 进程数（Tasks）、cpu使用情况、内存使用情况以及交换分区使用情况。其实上面这些内容可以通过其他命令来查看，
 所以，用top重点查看的还是下面的进程使用系统资源详细状况。这部分东西反映的东西还是比较多的，
 不过需要你关注的也就几项：%CPU、 %MEM、COMMAND 这些项目所代表的意义，不用多介绍相信你也能看懂吧。
 RES这一项为进程所占内存大小，而%MEM为使用内存百分比。在top状态下，按―shift + m‖，
 可以按照内存使用大小排序。按数字1可以列出各颗cpu的使用状态

	top -bp1


sar
	yum install sysstat

	sar命令很强大，它可以监控系统所有资源状态。比如，平均负载、网卡流量、磁盘状态、内存使用等。
	它不同于其他系统状态监控工具的地方在于，它可以打印历史信息，可以显示当天从零点开始到当前时刻的系统状态信息。
	如果你的系统没有安装这个命令，请使用―yum install -y sysstat‖命令安装。初次使用sar命令会报错，
	那是因为sar工具还没有生成相应的数据库文件（时时监控就不会了，因为不用去查询那个库文件）。
	它的数据库文件在―/var/log/sa/‖目录下



free	当前系统的总内存大小以及使用内存的情况
	
free -h
			  total       used       free     shared    buffers     cached
Mem:          980M       892M        88M       308K        49M       212M
-/+ buffers/cache:       630M       350M
Swap:         3.9G         0B       3.9G
	
从上例中可看到当前系统内存总大小为326616（单位是k）已经使用137332， 剩余189284。
其实真正剩余并不是这个189284，而是第二行的297100，真正使用的也是第二行的29516。
这是因为系统初始化时，就已经分配出很大一部分内存给缓存，这部分缓存用来随时提供给程序使用。
如果程序不用，那这部分内存就空闲。所以，查看内存使用多少，剩余多少请看第二行的数据。
另外我们还可以加-m或者-g选项分别以Mb或Gb为单位打印内存使用状况:

	free -m
	free -h

ps 查看进程
	ps aux
	ps -elf
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.1  19360  1524 ?        Ss   09:43   0:01 /sbin/init
root          2  0.0  0.0      0     0 ?        S    09:43   0:00 [kthreadd]
root          3  0.0  0.0      0     0 ?        S    09:43   0:00 [migration/0]
root          4  0.0  0.0      0     0 ?        S    09:43   0:00 [ksoftirqd/0]
root          5  0.0  0.0      0     0 ?        S    09:43   0:00 [stopper/0]
root          6  0.0  0.0      0     0 ?        S    09:43   0:00 [watchdog/0]
root          7  0.0  0.0      0     0 ?        S    09:43   0:00 [migration/1]

PID ：进程的id，这个id很有用，在linux中内核管理进程就得靠pid来识别和管理某一个程，
比如我想终止某一个进程，则用―kill 进程的pid‖，但有时并不能杀掉，则需要加一个-9选项了―kill -9 进程pid‖ 
STAT ：表示进程的状态，进程状态分为以下几种（不要求记住，但要了解） 
D 不能中断的进程（通常为IO） 
R 正在运行中的进程 
S 已经中断的进程，通常情况下，系统中大部分进程都是这个状态 
T 已经停止或者暂停的进程，如果我们正在运行一个命令，
比如说 sleep 10 如果我们按一下ctrl -z 让他暂停，那么我们用ps查看就会显示T这个状态 W 这个好像是说，
从内核2.6xx 以后，表示为没有足够的内存页分配 X 已经死掉的进程（这个好像从来不会出现）

Z 僵尸进程，杀不掉，打不死的垃圾进程，占系统一小点资源，不过没有关系。如果太多，就有问题了。一般不会出现。
< 高优先级进程 
N 低优先级进程 
L 在内存中被锁了内存分页 
s 主进程 l 多线程进程 
+ 代表在前台运行的进程 
这个ps命令是我在工作中用的非常多的命令之一，所以请记住它吧。
关于ps命令的使用，我经常会连同管道符一起使用，用来查看某个进程或者它的数量。


netstat
	打印网络连接状况、系统所开放端口、路由表等信息。
	我最常用的关于netstat的命令就是这个netstat -lnp（打印当前系统启动哪些端口）
	以及netstat -an（打印网络连接状况）

-a (all)显示所有选项，默认不显示LISTEN相关
-t (tcp)仅显示tcp相关选项
-u (udp)仅显示udp相关选项
-n 拒绝显示别名，能显示数字的全部转化成数字。
-l 仅列出有在 Listen (监听) 的服務状态

-p 显示建立相关链接的程序名
-r 显示路由信息，路由表
-e 显示扩展信息，例如uid等
-s 按各个协议进行统计
-c 每隔一个固定时间，执行该netstat命令。

提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到


列出所有端口 netstat -a
列出所有 tcp 端口 netstat -at
列出所有 udp 端口 netstat -au
只显示监听端口 netstat -l
只列出所有监听 tcp 端口 netstat -lt
只列出所有监听 udp 端口 netstat -lu
只列出所有监听 UNIX 端口 netstat -lx
显示所有端口的统计信息 netstat -s
显示 TCP 或 UDP 端口的统计信息 netstat -st 或 -su
在 netstat 输出中显示 PID 和进程名称 netstat -p
在 netstat 输出中不显示主机，端口和用户名 (host, port or user) netstat -an
netstat 将每隔一秒输出网络信息。netstat -c
显示核心路由信息 netstat -r
显示网络接口列表 netstat -i
显示详细信息，像是 ifconfig 使用 netstat -ie



tcpdump
	tcpdump -nn -i eth0




selinux
	vi /etc/selinux/config
	vi /etc/sysconfig/selinux

	getenforce 命令获得当前selinux的状态


crontab
	-u：指定某个用户，不加-u选项则为当前用户 
	-e：制定计划任务 
	-l：列出计划任务 
	-r：删除计划任务

ntsysv


chkconfig
	--add
	--del
	--list
	chkconfig --level 3 crond off
	chkconfig crond on
chkconfig	检查、设置系统的各种服务
	--list	列出所有的系统服务
	--add 服务名  增加所指定的系统服务，让chkconfig指令得以管理它，并同时在系统启动的叙述文件内增加相关数据
	--del 服务名	删除所指定的系统服务，不再由chkconfig指令管理，并同时在系统启动的叙述文件内删除相关数据

	chkconfig --add httpd
	chkconfig --del httpd
	chkconfig --level httpd 2345 on 把httpd在运行级别为2、3、4、5的情况下都是on（开启）的状态
	chkconfig --level 35 mysql on
	chkconfig mysqld on

	如何增加一个服务：
1.服务脚本必须存放在/etc/ini.d/目录下；
2.chkconfig --add servicename
    在chkconfig工具服务列表中增加此服务，此时服务会被在/etc/rc.d/rcN.d中赋予K/S入口了；
3.chkconfig --level 35 mysqld on
    修改服务的默认启动等级。


service   用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等

	service name start|stop|status
	service --status-all




linux日志
	先来看看配置文件/etc/rsyslog.conf 。centos6默认改为rsyslog.conf之前版本是syslog.conf。
	该配置文件主要信息为：记录哪些服务和需要记录什么等级的信息。 
	日志格式： 
	auth –pam产生的日志 
	authpriv –ssh,ftp等登录信息的验证信息
	cron –时间任务相关 
	kern –内核 
	lpr –打印 
	mail –邮件
	mark(syslog)–rsyslog服务内部的信息,时间标识 
	news –新闻组 
	user –用户程序产生的相关信息 
	uucp –unix to unix copy, unix主机之间相关的通讯 
	local 1~7 –自定义的日志设备


	日志级别: 
	debug –有调式信息的，日志信息最多 
	info –一般信息的日志，最常用 
	notice –最具有重要性的普通条件的信息 
	warning –警告级别 
	err –错误级别，阻止某个功能或者模块不能正常工作的信息 
	crit –严重级别，阻止整个系统或者整个软件不能正常工作的信息 
	alert –需要立刻修改的信息 
	emerg –内核崩溃等严重信息 
	none –什么都不记录

	从上到下，级别从低到高，记录的信息越来越少 
	连接符号 
	. : 表示大于等于xxx级别的信息 
	.=：表示等于xxx级别的信息 
	.!：表示在xxx之外的等级的信息

	/var/log/messages核心系统日志文件 这个日志是Linux系统最核心的日志文件，
	假若某个服务没有定义日志，那么该服务产生的日志就会到这个文件中。该日志每周归档一次。 
	[root@localhost ~]# ls /var/log/messages* /var/log/messages /var/log/messages-20150809 
	/var/log/messages-20150726 /var/log/messages-20150816 /var/log/messages-20150802 它是如何归档的，根据/etc/logrotate.conf来控制的。/var/log/messages由syslogd这个守护进程产生的，如果停掉这个服务则系统不会产/var/log/messages 
	/var/log/wtmp日志用来查看用户登录历史，但这个文件不能直接cat查看，只能用命令last查看。 
	/var/log/btmp日志和wtmp类似，也不能直接cat查看，用命令lastb 查看，记录无效登录历史。 
	/var/log/maillog是用来记录邮件相关的信息，比如发给谁邮件，是否发出去等信息。
	/var/log/secure是一个安全认证相关的日志，比如系统用户登录时，正常登录或者登录失败都会记录，
	另外ftp服务相关的登录日志也会记录到这里面来。 
	dmesg这是一个命令，主要查看系统时时的硬件设备抛出的信息，如果磁盘异常或者网络异常或者内核异常都会记录下来。 
	只不过这些信息是存到内存里面的，系统重启后就消失了。 
	/var/log/dmesg，这是一个日志，记录系统系统时硬件相关的信息。

	

归档压缩
xz
-d：  解压缩

　　-z： 压缩文件

　　-t： 测试文件的一致性

　　-l： 列出文件的信息xz 【选项】 待压缩的文件
常用选项：
-z强制压缩
-d解压缩.xz结尾的压缩文件
如：
xz glib-2.36.0.tar 
xz -d glib-2.36.0.tar.xz
xz 命令的基本用法
xz 命令帮助信息
 $ xz --help 
 Usage: xz [OPTION]... [FILE]... 
 Compress or decompress FILEs in the .xz format. 

  -z, --compress      force compression 
  -d, --decompress    force decompression 
  -t, --test          test compressed file integrity 
  -l, --list          list information about .xz files 
  -k, --keep          keep (don't delete) input files 
  -f, --force         force overwrite of output file and (de)compress links 
  -c, --stdout        write to standard output and don't delete input files 
  -0 ... -9           compression preset; default is 6; take compressor *and* 
                      decompressor memory usage into account before using 7-9! 
  -e, --extreme       try to improve compression ratio by using more CPU time; 
                      does not affect decompressor memory requirements 
  ... 

压缩一个文件 test.txt，压缩成功后生成 test.txt.xz, 原文件会被删除。
 $ xz test.txt 
 $ ls test.txt* 
 test.txt.xz 

解压 test.txt.xz 文件，并使用参数 -k 保持原文件不被删除，
 $ xz -d -k test.txt.xz 
 $ ls test.txt* 
 test.txt.xz test.txt 

使用参数 -l 显示 .xz 文件的基本信息。基本信息包括压缩率、数据完整性验证方式等。也可以和参数 -v 或 -vv 配合显示更详尽的信息。
 $ xz -l index.txt.xz 
 Strms  Blocks   Compressed Uncompressed  Ratio  Check   Filename 
    1       1        768 B      1,240 B  0.619  CRC64   index.txt.xz 

使用参数 -0, -1, -2, … -6, … -9 或参数 --fast, --best 设定压缩率。xz 命令的默认为 -6 ，对于大多数系统来说，甚至是一些较旧的系统，-4 … -6 压缩率预设值都不错的表现。
 $ xz -k7 xz_pipe_decomp_mini.c 
 $ xz -k --fast xz_pipe_decomp_mini.c 

和 tar 命令配合处理多个文件。一般来说，有两种简单的方法将 tar 和 xz 结合起来，一是使用管道，或是使用 tar 命令的参数'J'。两种方法各自有各自的优点，第一种方法可以充分利用 xz 利用丰富的参数。而第二种方法使用起来更简单容易。例子分别如下
使用管道
 $  tar cf -  *.c  | xz --best > src.tar.xz 　 # compress 
 $  xz -d src.tar.xz --stdout | tar -x        # decompress 

使用 tar 参数 "J
 $  tar cJf src.txz  *.c                      # compress 
 $  tar xJf src.txz                           # decompress 

"
复杂的用法
使用参数 -H 显示 xz 命令所有 options. 参数 -H 比使用参数 --help 显示的内容更详细。
 $ xz -H  | more 

借助 xargs 命令并行压缩多文件。下面的命令行可以将 /var/log 目录下所有的扩展名为 .log 的文件压缩。通过 xargs 命令同时运行多个 xz 进行压缩。
 # find /var/log -type f -iname "*.log" -print0 | xargs -P4 -n16 xz -T1 

注意：运行此命令须有 root 权限。
连接 (concatenation) 多个 .xz 文件。可以把多个压缩数据流连接 (concatenation) 到一个文件中。解压缩时，就像解压一个正常单压缩流文件一样。如下例，两个 .xz 文件 concat_1.txt.xz 和 concat_2.txt.xz, 用 cat 命令将他们合并为文件 concat.xz，解压缩 concat.xz 这个文件会发现 concat_1.txt.xz 和 concat_2.txt.xz 中的内容合并在一起了。
 $ xzcat concat_1.txt.xz 
 .xz file concatenation test: ~ file1 ~ 
 $ xzcat concat_2.txt.xz 
 .xz file concatenation test: ~ file2 ~ 
 $ cat concat_1.txt.xz concat_2.txt.xz > concat.txt.xz  #concatenation 
 $ xz -d concat.txt.xz                   #decompress 
 $ cat concat.txt                         #print file concat.txt 
 .xz file concatenation test: ~ file1 ~ 
 .xz file concatenation test: ~ file2 ~ 

适于 shell 编程的 Robot 模式。xz 命令使用参数 --robot 输出易于 shell 处理的信息。
 $ xz --list xz_pipe_mini.exe.xz            ## normal output 
 Strms  Blocks   Compressed Uncompressed  Ratio  Check   Filename 
    2       2     12.8 KiB     42.7 KiB  0.300  CRC64   xz_pipe_mini.exe.xz 
 $ xz --list --robot  xz_pipe_mini.exe.xz   ## robot model 
 name    xz_pipe_mini.exe.xz 
 file    2       2       13112   43695   0.300   CRC64   0 
 totals  2       2       13112   43695   0.300   CRC64   0       1 

下例是利用 --robot 打印出文件压缩率的一个例子：
 $ xz -l --robot xz_pipe_mini.exe.xz | gawk \ 
        '/^name/ {printf "%s =>",$2} \ 
         /^totals/ {printf "compressed radio:%.2f%\n", $6 * 100}'
 xz_pipe_mini.exe.xz =>compressed radio:30.00% 

自定义 filter Chain. 有时需要一些特殊的设定，以满足一些特定需求。xz 提供了很多 参数自定义压缩细节。下面有两个例子
若希望解压缩使用很少内存，比如在嵌入式系统中解压。可以使用使用参数 -e，并设定压缩使用的字典大小为 64KB。参数 -e (--extreme) 是指使用稍慢的压缩速度以尝试稍稍提高一些压缩率。这样便可在解压缩时使用很少的内存空间。命令如下：
$ xz --check=crc32 --lzma2=preset=6e,dict=64KiB file
若压缩文件中是可执行的二进制数据时，使用的合适的 BCJ(branch/call/jump) filter 可以提高压缩率。例如 libwx_gtk2u_core-2.8.so.0.8.0 是 wxGTK 库的一个共享库文件，它原始的大小为 3980KB. 若采用默认的参数压缩后的大小为 916KB. 通过相应指定 filter Chain, 可以生成更小些的文件 .
 $ xz libwx_gtk2u_core-2.8.so.0.8.0 
 $ du -k libwx_gtk2u_core-2.8.so.0.8.0.xz 
 916 libwx_gtk2u_core-2.8.so.0.8.0.xz 
 $ xz --x86 --lzma2 libwx_gtk2u_core-2.8.so.0.8.0 
 $ du -k libwx_gtk2u_core-2.8.so.0.8.0.xz 
 856     libwx_gtk2u_core-2.8.so.0.8.0.xz 

从上面执行结果来看，利用合适的 filter Chain 最终生成的文件大小为 865KB。参数 --x86 --lzma2 就组成了一个 filter Chain。参数 --x86 是指使用 x86 平台的 BCJ filter，适用于 32 位和 64 位系统。参数 --lzma2 则指使用 lzma2 算法进行压缩。
回页首
使用 xzgrep,xzcat,xzdiff 等实用工具
xzcat
xzcat 命令其相当于 "xz --decompress --stdout" 就是将解压出的数据输出到标准输出 (stdout)。下面的例子用来统计压缩 test.txt.xz 文件所包含数据的行数。
$ xzcat test.txt.xz | wc -l  ## count the lines of test.txt

xzgrep
xzgrep 可以用来 grep 压缩文件所包含的数据内容。其内部就是调用 grep 命令，所以参数和 grep 一致。下面的例子打印出 xz_pipe_comp_mini.c.xz 中所有包含以"lzma_"开头单词的行号和行内容。例：
 $ xzgrep -P -n "lzma_\w+" xz_pipe_comp_mini.c.xz 
 8:    lzma_check check = LZMA_CHECK_CRC64; 
 9:    lzma_stream strm = LZMA_STREAM_INIT; /* alloc and init lzma_stream struct */ 
 15:    lzma_easy_encoder (&strm, 6, LZMA_CHECK_CRC64); 
 28:        lzma_action action = in_finished ? LZMA_FINISH : LZMA_RUN; 
 35:            lzma_code (&strm, action); /* compress data */ 
 42:     lzma_end (&strm); 

xzless 和 xzmore
这两个命令可以分页查看压缩文件中的内容。简单的来说，相当于
"xzcat  | less" 或 "xzcat  | more"

xzdiff 和 xzcmp
这两个命令用于比较两个 .xz 文件。内部分别调用命令 diff 和 cmp 来实现文件内容的比较。例：
 $ xzdiff xz_pipe_comp_mini.c.orig.xz xz_pipe_comp_mini.c.xz 
 20c20 
 <         if (feof (in_file)) 
 --- 
 >         if (feof (in_file))  { 
 21a22 
 >         } 
 $ 

回页首
liblzma API
关于 liblzma API
liblzma API 提供了 LZMA1/LZMA2 算法的实现，并具有类似于 Zlib 的 API 接口。也和 gzip、bzip2 一样 XZ Utils 是流压缩格式。通过 liblzma API 接口，可以相对简单的编程实现对数据的压缩和解压缩。
使用 liblzma API 压缩数据
使用 liblzma 压缩数据的过程，大致过程如下。
定义 lzma_stream 结构体变量并使用 LZMA_STREAM_INIT 初始化，这个 lzma_stream 结构体变量会在整个数据压缩过程中被使用。有点类似于 C 中标准库中文件处理使用的结构体 FILE 。
   lzma_stream strm = LZMA_STREAM_INIT; 

调用 lzma_easy_encoder 函数做压缩准备工作。函数的第一参数是 lzma_stream. 结构体变量的指针，第二参数则指明了期望压缩率大小。有效值为 [0,9], 数字越高压缩率越高。第三参数是指明数据完整性检查方法，LZMA_CHECK_CRC64 可以满足大多数情况需要。当然，还有 LZMA_CHECK_CRC32, LZMA_CHECK_SH256 可供选择，或者使用 LZMA_CHECK_NONE 不进行 数据完整性检查。
lzma_easy_encoder (&strm, 6, LZMA_CHECK_CRC64);
通过设定 lzma_stream 结构体变量中的 next_in 和 avail_in 字段，指明待压缩的数据开始 地址和长度。
 strm.next_in  = in_buf;  //input buffer address. 
 strm.avail_in = in_len;  //data length. 

通过设定 lzma_stream 结构体变量中的 next_out 和 avail_out 字段，指明存放压缩结果 buffer 地址和长度。
 strm.next_out = out_buf;  //output buffer address 
 strm.avail_out = 4096;    //output buffer length. 

然后通过调用 lzma_code 函数来压缩数据，或结束压缩数据。lzma_code 函数有两个参数，第一个参数是 lzma_stream 指针。而第二个参数用来指明 lzma_code 的动作： LZMA_RUN: 进行数据处理； LZMA_FINISH: 结束数据处理。
 lzma_code (&strm, LZMA_RUN);    /* compress data */ 
 lzma_code (&strm, LZMA_FINISH); /* Finish operation.*/ 

最后要调用 lzma_end 函数释放资源，退出。
 lzma_end(&strm); 

下面是一段完整的示例程序。所示程序从标准输入 (stdin) 读入数据，压缩后写到标准输出 (stdout). 为了更便于理解压缩过程，示例代码省略了所有的异常处理和一些其他次要细节。



[root@station ~]# xz --help
Usage: xz [OPTION]... [FILE]...
Compress or decompress FILEs in the .xz format.

Mandatory arguments to long options are mandatory for short options too.

  -z, --compress      force compression
  -d, --decompress    force decompression
  -t, --test          test compressed file integrity
  -l, --list          list information about files
  -k, --keep          keep (don't delete) input files
  -f, --force         force overwrite of output file and (de)compress links
  -c, --stdout        write to standard output and don't delete input files
  -0 .. -9            compression preset; 0-2 fast compression, 3-5 good
                      compression, 6-9 excellent compression; default is 6
  -e, --extreme       use more CPU time when encoding to increase compression
                      ratio without increasing memory usage of the decoder
  -q, --quiet         suppress warnings; specify twice to suppress errors too
  -v, --verbose       be verbose; specify twice for even more verbose
  -h, --help          display this short help
  -H, --long-help     display the long help (lists also the advanced options)
  -V, --version       display the version number

With no FILE, or when FILE is -, read standard input.

Report bugs to <lasse.collin@tukaani.org> (in English or Finnish).
XZ Utils home page: <http://tukaani.org/xz/>




bzip2




bzip2命令文件压缩与解压
bzip2命令用于创建和管理（包括解压缩）“.bz2”格式的压缩包。我们遇见Linux压缩打包方法有很多种，
以下讲解了Linux压缩打包方法中的Linux bzip2命令的多种范例供大家查看，相信大家看完后会有很多收获。

语法
bzip2(选项)(参数)
选项
-c或——stdout：将压缩与解压缩的结果送到标准输出；
-d或——decompress：执行解压缩；
-f或-force：bzip2在压缩或解压缩时，若输出文件与现有文件同名，预设不会覆盖现有文件。若要覆盖。请使用此参数；
-h或——help：在线帮助；
-k或——keep：bzip2在压缩或解压缩后，会删除原始文件。若要保留原始文件，请使用此参数；
-s或——small：降低程序执行时内存的使用量；
-t或——test：测试.bz2压缩文件的完整性；
-v或——verbose：压缩或解压缩文件时，显示详细的信息；
-z或——compress：强制执行压缩；
-V或——version：显示版本信息；
--repetitive-best：若文件中有重复出现的资料时，可利用此参数提高压缩效果；
--repetitive-fast：若文件中有重复出现的资料时，可利用此参数加快执行效果。
参数
文件：指定要压缩的文件。

实例
压缩指定文件filename:

bzip2 filename
或
bzip2 -z filename
这里，压缩的时候不会输出，会将原来的文件filename给删除，替换成filename.bz2.如果以前有filename.bz2则不会替换并提示错误（如果想要替换则指定-f选项，例如bzip2 -f filename；如果filename是目录则也提醒错误不做任何操作；如果filename已经是压过的了有bz2后缀就提醒一下，不再压缩，没有bz2后缀会再次压缩。

解压指定的文件filename.bz2:

bzip2 -d filename.bz2
或
bunzip2 filename.bz2
这里，解压的时候没标准输出，会将原来的文件filename.bz2给替换成filename。如果以前有filename则不会替换并提示错误（如果想要替换则指定-f选项，例如bzip2 -df filename.bz2。

压缩解压的时候将结果也输出：

$bzip2 -v filename
输入之后，输出如下：

filename:  0.119:1, 67.200 bits/byte, -740.00% saved, 5 in, 42 out.
这里，加上-v选项就会输出了,只用压缩举例了，解压的时候同理bzip2 -dv filename.bz2不再举例了。

模拟解压实际并不解压：

bzip2 -tv filename.bz2
输入之后，输出如下：

filename.bz2: ok
这里，-t指定要进行模拟解压，不实际生成结果，也就是说类似检查文件,当然就算目录下面有filename也不会有什么错误输出了，因为它根本不会真的解压文件。为了在屏幕上输出，这里加上-v选项了,如果是真的解压bzip2 -dv filename.bz2则输出的是把"ok"替换成了"done"。

压缩解压的时候，除了生成结果文件，将原来的文件也保存:

bzip2 -k filename
这里，加上-k就保存原始的文件了，否则原始文件会被结果文件替代。只用压缩举例了，解压的时候同理$bzip2 -dk filename.bz2不再举例了。

解压到标准输出：

bzip2 -dc filename.bz2
输入之后，输出如下：

hahahhaahahha
这里，使用-c指定到标准输出，输出的是文件filename的内容，不会将filename.bz2删除。

压缩到标准输出：

bzip2 -c filename
bzip2: I won't write compressed data to a terminal.
bzip2: For help, type: `bzip2 --help'.
这里，使用-c指定压缩到标准输出不删除原有文件，不同的是，压缩后的文件无法输出到标准输出。

使用bzip2的时候将所有后面的看作文件(即使文件名以'-'开头)：

bzip2 -- -myfilename
这里主要是为了防止文件名中-产生以为是选项的歧义。




zip
zip命令文件压缩与解压
zip命令可以用来解压缩文件，或者对文件进行打包操作。zip是个使用广泛的压缩程序，文件经它压缩后会另外产生具有“.zip”扩展名的压缩文件。

语法
zip(选项)(参数)
选项
-A：调整可执行的自动解压缩文件；
-b<工作目录>：指定暂时存放文件的目录；
-c：替每个被压缩的文件加上注释；
-d：从压缩文件内删除指定的文件；
-D：压缩文件内不建立目录名称；
-f：此参数的效果和指定“-u”参数类似，但不仅更新既有文件，如果某些文件原本不存在于压缩文件内，使用本参数会一并将其加入压缩文件中；
-F：尝试修复已损坏的压缩文件；
-g：将文件压缩后附加在已有的压缩文件之后，而非另行建立新的压缩文件；
-h：在线帮助；
-i<范本样式>：只压缩符合条件的文件；
-j：只保存文件名称及其内容，而不存放任何目录名称；
-J：删除压缩文件前面不必要的数据；
-k：使用MS-DOS兼容格式的文件名称；
-l：压缩文件时，把LF字符置换成LF+CR字符；
-ll：压缩文件时，把LF+cp字符置换成LF字符；
-L：显示版权信息；
-m：将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中；
-n<字尾字符串>：不压缩具有特定字尾字符串的文件；
-o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同；
-q：不显示指令执行过程；
-r：递归处理，将指定目录下的所有文件和子目录一并处理；
-S：包含系统和隐藏文件；
-t<日期时间>：把压缩文件的日期设成指定的日期；
-T：检查备份文件内的每个文件是否正确无误；
-u：更换较新的文件到压缩文件内；
-v：显示指令执行过程或显示版本信息；
-V：保存VMS操作系统的文件属性；
-w：在文件名称里假如版本编号，本参数仅在VMS操作系统下有效；
-x<范本样式>：压缩时排除符合条件的文件；
-X：不保存额外的文件属性；
-y：直接保存符号连接，而非该链接所指向的文件，本参数仅在UNIX之类的系统下有效；
-z：替压缩文件加上注释；
-$：保存第一个被压缩文件所在磁盘的卷册名称；
-<压缩效率>：压缩效率是一个介于1~9的数值。
参数
zip压缩包：指定要创建的zip压缩包；
文件列表：指定要压缩的文件列表。
实例
将/home/Blinux/html/这个目录下所有文件和文件夹打包为当前目录下的html.zip：

zip -q -r html.zip /home/Blinux/html
上面的命令操作是将绝对地址的文件及文件夹进行压缩，以下给出压缩相对路径目录，比如目前在Bliux这个目录下，执行以下操作可以达到以上同样的效果：

zip -q -r html.zip html
比如现在我的html目录下，我操作的zip压缩命令是：

zip -q -r html.zip *



unzip：

unzip命令文件压缩与解压
unzip命令用于解压缩由zip命令压缩的“.zip”压缩包。

语法
unzip(选项)(参数)
选项
-c：将解压缩的结果显示到屏幕上，并对字符做适当的转换；
-f：更新现有的文件；
-l：显示压缩文件内所包含的文件；
-p：与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换；
-t：检查压缩文件是否正确；
-u：与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中；
-v：执行时显示详细的信息；
-z：仅显示压缩文件的备注文字；
-a：对文本文件进行必要的字符转换；
-b：不要对文本文件进行字符转换；
-C：压缩文件中的文件名称区分大小写；
-j：不处理压缩文件中原有的目录路径；
-L：将压缩文件中的全部文件名改为小写；
-M：将输出结果送到more程序处理；
-n：解压缩时不要覆盖原有的文件；
-o：不必先询问用户，unzip执行后覆盖原有的文件；
-P<密码>：使用zip的密码选项；
-q：执行时不显示任何信息；
-s：将文件名中的空白字符转换为底线字符；
-V：保留VMS的文件版本信息；
-X：解压缩时同时回存文件原来的UID/GID；
-d<目录>：指定文件解压缩后所要存储的目录；
-x<文件>：指定不要处理.zip压缩文件中的哪些文件；
-Z：unzip-Z等于执行zipinfo指令。
参数
压缩包：指定要解压的“.zip”压缩包。

实例
将压缩文件text.zip在当前目录下解压缩。

unzip test.zip
将压缩文件text.zip在指定目录/tmp下解压缩，如果已有相同的文件存在，要求unzip命令不覆盖原先的文件。

unzip -n test.zip -d /tmp
查看压缩文件目录，但不解压。

unzip -v test.zip
将压缩文件test.zip在指定目录/tmp下解压缩，如果已有相同的文件存在，要求unzip命令覆盖原先的文件。

unzip -o test.zip -d tmp/




gzip：



gzip
命令格式：
gzip[参数][文件或者目录]
2．命令功能：
gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名。 
 

gzip命令文件压缩与解压
gzip命令用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。

gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。

语法
gzip(选项)(参数)
选项
-a或——ascii：使用ASCII文字模式；
-d或--decompress或----uncompress：解开压缩文件；
-f或——force：强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接；
-h或——help：在线帮助；
-l或——list：列出压缩文件的相关信息；
-L或——license：显示版本与版权信息；
-n或--no-name：压缩文件时，不保存原来的文件名称及时间戳记；
-N或——name：压缩文件时，保存原来的文件名称及时间戳记；
-q或——quiet：不显示警告信息；
-r或——recursive：递归处理，将指定目录下的所有文件及子目录一并处理；
-S或<压缩字尾字符串>或----suffix<压缩字尾字符串>：更改压缩字尾字符串；
-t或——test：测试压缩文件是否正确无误；
-v或——verbose：显示指令执行过程；
-V或——version：显示版本信息；
-<压缩效率>：压缩效率是一个介于1~9的数值，预设值为“6”，指定愈大的数值，压缩效率就会愈高；
--best：此参数的效果和指定“-9”参数相同；
--fast：此参数的效果和指定“-1”参数相同。
参数
文件列表：指定要压缩的文件列表。

实例
把test6目录下的每个文件压缩成.gz文件

gzip *
把上例中每个压缩的文件解压，并列出详细的信息

gzip -dv *
详细显示例1中每个压缩的文件的信息，并不解压

gzip -l *
压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz

gzip -r log.tar
递归的压缩目录

gzip -rv test6
这样，所有test下面的文件都变成了*.gz，目录依然存在只是目录里面的文件相应变成了*.gz.这就是压缩，和打包不同。因为是对目录操作，所以需要加上-r选项，这样也可以对子目录进行递归了。

递归地解压目录

gzip -dr test6




tar
tar命令文件压缩与解压
tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。

首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。

为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。

语法
tar(选项)(参数)
选项
-A或--catenate：新增文件到以存在的备份文件；
-B：设置区块大小；
-c或--create：建立新的备份文件；
-C <目录>：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。
-d：记录文件的差别；
-x或--extract或--get：从备份文件中还原文件；
-t或--list：列出备份文件的内容；
-z或--gzip或--ungzip：通过gzip指令处理备份文件；
-Z或--compress或--uncompress：通过compress指令处理备份文件；
-f<备份文件>或--file=<备份文件>：指定备份文件；
-v或--verbose：显示指令执行过程；
-r：添加文件到已经压缩的文件；
-u：添加改变了和现有的文件到已经存在的压缩文件；
-j：支持bzip2解压文件；
-v：显示操作过程；
-l：文件系统边界设置；
-k：保留原有文件不覆盖；
-m：保留文件不被覆盖；
-w：确认压缩文件的正确性；
-p或--same-permissions：用原来的文件权限还原文件；
-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；
-N <日期格式> 或 --newer=<日期时间>：只将较指定日期更新的文件保存到备份文件里；
--exclude=<范本样式>：排除符合范本样式的文件。
参数
文件或目录：指定要打包的文件或目录列表。

实例
将文件全部打包成tar包：

tar -cvf log.tar log2012.log    仅打包，不压缩！ 
tar -zcvf log.tar.gz log2012.log   打包后，以 gzip 压缩 
tar -jcvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 
在选项f之后的文件档名是自己取的，我们习惯上都用 .tar 来作为辨识。 如果加z选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加j选项，则以.tar.bz2来作为tar包名。

查阅上述tar包内有哪些文件：

tar -ztvf log.tar.gz
由于我们使用 gzip 压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上z这个选项了。

将tar包解压缩：

tar -zxvf /opt/soft/test/log.tar.gz
在预设的情况下，我们可以将压缩档在任何地方解开的

只将tar内的部分文件解压出来：

tar -zxvf /opt/soft/test/log30.tar.gz log2013.log
我可以透过tar -ztvf来查阅 tar 包内的文件名称，如果单只要一个文件，就可以透过这个方式来解压部分文件！

文件备份下来，并且保存其权限：

tar -zcvpf log31.tar.gz log2014.log log2015.log log2016.log
这个-p的属性是很重要的，尤其是当您要保留原本文件的属性时。

在文件夹当中，比某个日期新的文件才备份：

tar -N "2012/11/13" -zcvf log17.tar.gz test
备份文件夹内容是排除部分文件：

tar --exclude scf/service -zcvf scf.tar.gz scf/*
其实最简单的使用 tar 就只要记忆底下的方式即可：

压　缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称
查　询：tar -jtv -f filename.tar.bz2
解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录


---------------------------------------------------------------------------------------------------------
date
	+%y 
	+%Y \
	+%m  -- +%F
	+%d /

	+%H \
	+%M --+ %T
	+%S /

	+%A
	+%a
	+%w
	+%W


系统时钟  date



	
	
	lsof
	-i
	-i 6
	-iTCP
	-i :22
	-i@192.168.100.1
	-i@192.168.100.1:22
	-i -sTCP:LISTEN
	
	